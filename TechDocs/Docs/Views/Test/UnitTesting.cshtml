@{
    ViewBag.Title = "UnitTesting";
}

<h2>UnitTesting</h2>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">The Basics of Unit Testing</div>
    </div>
    <div class="panel-body">
        <blockquote>
            <p>
                <strong>Definition 1.0</strong>: A <em>unit test</em> is a piece of code(usually a method) which calls another piece of code and checks the correctness of some assumptions afterwards. If the assumption turns out to be wrong, the unit test has failed. The <em>unit</em> is a method or function.
            </p>
        </blockquote>
        <p>A <em>unit of work</em> can be described as the collection of actions that take place in betweeen <strong>invoking a public api</strong>@Html.Raw("<------>")<strong>observing a single noticeable end result</strong>. This end result can be observed without looking inside the private implementations of the system and only through a public api.</p>
        <p>
            End result can be one of the following
            <ul>
                <li>a return value (will happen only for public api which do not return a void)</li>
                <li>a noticeable change to the state or behavior to the system visible only through public apis.(example a state machine that changed its state)</li>
                <li>a callout to a third party system( this callout is a noticeable end result)</li>
            </ul>
        </p>
        <p>If the idea is to carry out a unit of work and see something noticeable, why should we have small unit of work?. This is like checking every small work if it is working fine when instead the bigger work can be checked in lesser time. Of course if you are 100% sure that your small works will work fine without any issue.</p>
        <blockquote>
            <p>
                <strong>Definition 1.1</strong>: A <em>unit test</em> is a piece of code that invokes a unit of work and checks one specific end result of that unit of work. if the assumptions on the end result fails then the unit test has failed. A unit test's scope can span as little as a method or as big as classes.
            </p>
        </blockquote>
        <p>We do test our code, but directly by using the product. Of course in development environment. But this is not a <em>good unit test</em></p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Properties of a Good Unit Test</div>
    </div>
    <div class="panel-body">
        <ul>
            <li>It should be automated and repeatable(should not be like everytime you run a test, you have a variable in between that you are chaning before you run)</li>
            <li>It should be easy to implement</li>
            <li>It should be relevant tomorrow(unit test should be time scalable, there are many system parameters that may change tomorrow)</li>
            <li>Anyone should be able to run it at the push of a button</li>
            <li>it shouldn't take too much time to run(you are not running the production product methods that might take lot of time to complete, or are asynchronous.)</li>
            <li>It should be consistent in the results(result should not change until you change the test itself)</li>
            <li>It should have full control of the unit under test(the unit under test should be inside a single environment i.e. your test environment, no part of it should be able to be changed by something outside the test environment)</li>
            <li>It should be fully isolated</li>
            <li>When it fails, it should be easy to find the problem.</li>
        </ul>
        Any test method that does not follow the above, is <em><strong>Integration Testing</strong></em>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Integration Tests</div>
    </div>
    <div class="panel-body">
        Properties of Integration Tests
        <ul>
            <li>Not fast</li>
            <li>Not consistent</li>
            <li>Uses real system time</li>
            <li>Uses real file system</li>
            <li>Uses real database</li>
        </ul>
        <p>Lets take an example of a Car. If a Car breaks down, its the whole car that doesn't works. Various small parts may work independently but when brought together fails. This is similar to when we test our application through UI.</p>
        <blockquote>
            <p>
                <strong>Definition</strong>: <em>Integration testing</em> is testing a unit of work without having full control over all of it and using one or more of its real dependencies like time, network, database, threads, random number generators etc.
            </p>
        </blockquote>
        <p>A <em>unit test</em> isolates the unit of work from its dependencies so that they are easily consistent in their result and can easily control and simulate any aspect of the unit's behavior.</p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">What makes unit tests good</div>
    </div>
    <div class="panel-body">
        <blockquote>
            <p>
                <strong>Final Definition</strong>: A <em>unit test</em> is an automated piece of code that invokes the unit of work being tested, and then checks some assumptions about a single end result of that unit. A unit test is almost always written using a unit test framework. It can be written easily and runs quickly. It's trustworthy, readable, maintainable. It's consistent in its results as long as production code hasn't changed.
            </p>
        </blockquote>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">A simple unit test example</div>
    </div>
    <div class="panel-body">
        Create console applications and have a reference of your code in it. Write test classes/test methods in the console application. Call those test methods in the console's Main method.
        <p>This is only when you are not using any unit testing framework</p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Test-driven Development</div>
    </div>
    <div class="panel-body">
        <p>Many people think that the best time to write tests is after the production code is written. But there is a growing number of group that prefer writing tests even before the production code is written. What will you test if there is no code?</p>
        <p>
            <img src="../../Content/Images/testing/1.png" alt="" />
        </p>
        <p>But what TDD actually is :</p>
        <p><img src="../../Content/Images/testing/2.png" alt="" /></p>

        <p>
            Steps of TDD
            <ul>
                <li>Write a failing test to prove code or functionality is missing from the end product</li>
                <li>Make the test pass by writing production code that meets the expectations of your test</li>
                <li>Refactor your code</li>
                <li>Write another test</li>
            </ul>
        </p>
        <blockquote>
            <p>
                <em>Refactoring</em> means changing a piece of code <em>without</em> changing its functionality. The code still does the same thing, but it becomes easier to maintain, read, debug, and change.
            </p>
        </blockquote>
        <p>
            Technically, one of the biggest benefits of TDD nobody tells you about is that by
            seeing a test fail, and then seeing it pass without changing the test, you’re basically
            testing the test itself. If you expect it to fail and it passes, you might have a bug in
            your test or you’re testing the wrong thing. If the test failed and now you expect
            it to pass, and it still fails, your test could have a bug, or it’s expecting the wrong
            thing to happen.
        </p>
        <p>
            The 3 core skills of successfull TDD
            <ul>
                <li>Knowing how to write good tests(this book teaches this)</li>
                <li>Writing them test-first</li>
                <li>Designing them well</li>
            </ul>
        </p>

    </div>
</div>

<br />

<h2>A First Unit Test</h2>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Why NUnit, Why not MSTest</div>
    </div>
    <div class="panel-body">
        <ul>
            <li>Because NUnit has more features. These features make it more readable, maintainable.</li>
            <li>Available via Nuget.</li>
        </ul>
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Frameworks for Unit Testing</div>
    </div>
    <div class="panel-body">
        What unit testing framework offer?
        <ul>
            <li>Easy to implement. Earlier we might have needed a <em>Console app</em>, a <em>UI</em> or a <em>Web Form</em> for testing because we didn't have much time to implement testing.</li>
            <li>Repeatable. With time your unit tests had to be written again.</li>
            <li>Coverage. Earlier each and every part of <em>logic</em> might not have been covered.</li>
        </ul>
        <p>In short we have been missing a <em>framework</em> for writing, running and reviewing unit tests and their results</p>
        <p>
            <img src="~/Content/Images/testing/3.png" />
        </p>
        <p>
            <img src="~/Content/Images/testing/4.png" />
        </p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">The LogAn project(log and notification)</div>
    </div>
    <div class="panel-body">
        The Scenario:
        <blockquote>
            <p>Your company has many internal products it uses to monitor its applications at customer sites. All these products write log files and place them in a special directory. The log files are written in a proprietary format that your company has come up with that can't be parsed by any existing third-party tools. You're tasked with building a product, LogAn, that can analyze these log files and find special cases and events in them. When it finds these cases and events, it should alert the appropriate parties.</p>
        </blockquote>
        <p>
            In this course, we will learn to write tests that verify LogAn's
            <ul>
                <li>parsing</li>
                <li>event-recognition</li>
                <li>notification abilities</li>
            </ul>
        </p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Loading up the Solution</div>
    </div>
    <div class="panel-body">
        I will be using Visual Studio 2013
        <p>The full solution can be found here <a href="https://github.com/royosherove/aout2">https://github.com/royosherove/aout2</a></p>
        <p>Or Let's begin by creating our own solution. Use the downloaded solution for reference of project setup.</p>
        <ul>
            <li>Open Visual Studio</li>
            <li><code>ctrl+shift+n</code> to create a new project</li>
            <li>Choose a Class Library project</li>
            <li>Project name: "LogAn", Solution name: "ArtOfUnitTesting"</li>
        </ul>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">The Solution</div>
    </div>
    <div class="panel-body">
        Let's begin with our first class:
        <p>
            @Html.DisplayCode(@"
public class LogAnalyzer
{
    public bool IsValidLogFileName(string fileName)
    {
        if(fileName.EndsWith("".SLF""))
        {
            return false;
        }
        return true;
    }
}
", "c#")
        </p>
        <p>
            This method has a bug, it returns <code>false</code> instead of <code>true</code> if the fileName ends with ".SLF". This is to show how a test looks like when it fails.
        </p>
        <p>
            The first test is to make sure the method returns true if the filename is valid. Here are the first steps for writing an automated test for the <code>IsValidLogFileName</code> method.
            <ul>
                <li>Add a new Class Library project to your solution which will contain your tests. Name it "LogAn.UnitTests"</li>
                <li>Add a new Class to that project that will hold your test methods. Name if "LogAnalyzerTests"</li>
                <li>Add a new method, name it <code>IsValidLogFileName_BadExtension_ReturnFalse</code></li>
            </ul>
        </p>
        <p>
            <img src="~/Content/Images/testing/8.png" />
        </p>
        <p>
            Here are the three parts of the test method name:
            <ul>
                <li><strong>UnitOfWorkName</strong>: The name of the method or group of methods or classes you're testing</li>
                <li>
                    <strong>Scenario</strong>: The conditions under which the unit is tested such as "bad login" or "invalid user" or "good password". You could describe the parameters being sent
                    to the public method or the initial state of the system when the unit of work is
                    invoked such as “system out of memory” or “no users exist” or “user already exists.”
                </li>
                <li>
                    <strong>Expected Behavior</strong>What you expect the tested method to do under the specified
                    conditions. This could be one of three possibilities: return a value as a
                    result (a real value, or an exception), change the state of the system as a result
                    (like adding a new user to the system, so the system behaves differently on the
                    next login), or call a third-party system as a result (like an external web service).
                </li>
            </ul>
        </p>
        <p>
            <img src="~/Content/Images/testing/9.png" />
        </p>
        <p>
            <img src="~/Content/Images/testing/10.png" />
        </p>
        <p>In practice we keep your production code and test code in separate projects</p>
        <p>Now as a last step for this section, add the reference of <em><strong>LogAn</strong></em> project to your test project</p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Installing NUnit</div>
    </div>
    <div class="panel-body">
        <ul>
            <li><code>ctrl+q</code> for quick launch</li>
            <li>Type "Package Manager Console", choose and click enter</li>
            <li>Choose Package source: "nuget.org", Default project: "LogAn.UnitTests"</li>
            <li>type <code>install-package nunit</code> and <code>enter</code>. This downloads NUnit files, adds a refernce of NUnit's dll to your project</li>
            <li>type <code>install-package nunit.runner</code>. This downloads the NUnit UI.</li>
        </ul>
        <p>
            <img src="~/Content/Images/testing/5.png" />
        </p>
        <p>
            <img src="~/Content/Images/testing/6.png" />
        </p>
        <p>
            <img src="~/Content/Images/testing/7.png" />
        </p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Using the NUnit attributes in your code</div>
    </div>
    <div class="panel-body">
        <p>NUnit uses an attribute scheme to recognize and load tests</p>
        <p>NUnit provides an assembly that contains these special attributes.</p>
        <p>
            NUnit/NUnit runner identify tests by
            <ul>
                <li><code>[TestFixture]</code></li>
                <li><code>[Test]</code></li>
            </ul>
        </p>
        <p>
            This is how your code would look like
            @Html.DisplayCode(@"
using NUnit.Framework;

namespace LogAn.UnitTests
{
    [TestFixture]
    public class LogAnalyzerTests
    {
        [Test]
        public void IsValidLogFileName_BadExtension_ReturnFalse()
        {

        }
    }
}

", "c#")
        </p>
        <blockquote>
            <p><strong>Tip</strong>: NUnit requires the test methods to be public, return void and accept no parameters. But sometimes even these can have parameters.</p>
        </blockquote>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Writing your first Test</div>
    </div>
    <div class="panel-body">
        A unit test comprises of 3 main actions:
        <ul>
            <li>Arrange(do whatever you will <em>need</em> to call the method under test. for example create parameter variables. Create a variable which will hold the <em>expected</em> end result of "Act")</li>
            <li>Act(call the method under test and store the end result somewhere)</li>
            <li>Assert(compare the end result of "Act" with what is expected and make a decision if the test passed or not)</li>
        </ul>
        <p>
            Here's the code:
            @Html.DisplayCode(@"
using NUnit.Framework;

namespace LogAn.UnitTests
{
    [TestFixture]
    public class LogAnalyzerTests
    {
        [Test]
        public void IsValidLogFileName_BadExtension_ReturnFalse()
        {
            //Arrange
            LogAnalyzer analyzer = new LogAnalyzer();

            //Act
            bool result = analyzer.IsValidLogFileName(""filewithbadextension.foo"");

            //Assert
            Assert.False(result);
        }
    }
}

", "c#")
        </p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">The <code>Assert</code> class</div>
    </div>
    <div class="panel-body">
        <ul>
            <li><code>Assert</code> class has static methods</li>
            <li>Bridge between your code and NUnit framework</li>
            <li>If the arguments that are passed in the <code>Assert</code> class turn out to be different that what you are expecting, NUnit will realize that the test has failed and will alert you</li>
            <li>You can optionally send the message to alert to <code>Assert</code></li>
            <li>
                Some big ones
                <ul>
                    <li><code>Assert.True()</code></li>
                    <li><code>Assert.False</code>-syntactic sugar</li>
                    <li><code>Assert.AreEqual(expectedObject, actualObject, message)</code>-to test if the values of <code>expectedObject</code> and <code>actualObject</code> are same</li>
                    <li><code>Assert.AreSame(expectedObject, actualObject, message)</code>-to test if both the arguments reference the same object</li>
                </ul>
            </li>
            <li>Try not to provide the <code>message</code>. For most cases your test method name should describe exactly what happened if the test failed</li>
        </ul>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Running your first test with NUnit</div>
    </div>
    <div class="panel-body">
        <p>Find "nunit.exe" and run it</p>
        <p>
            <img src="~/Content/Images/testing/11.png" />
        </p>
        <p>
            <img src="~/Content/Images/testing/12.png" />
        </p>
        <p>
            <img src="~/Content/Images/testing/13.png" />
        </p>
        <p>
            <img src="~/Content/Images/testing/14.png" />
        </p>
        <p>
            The test failed, lets fix the code and try to pass the test
            @Html.DisplayCode(@"

namespace LogAn
{
    public class LogAnalyzer
    {
        public bool IsValidLogFileName(string fileName)
        {
            if (!fileName.EndsWith("".SLF""))
            {
                return false;
            }
            return true;
        }
    }
}

", "c#")
        </p>
        <p>
            <img src="~/Content/Images/testing/15.png" />
        </p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Adding some Positive Tests</div>
    </div>
    <div class="panel-body">
        <p>
            Notice this is not TDD. Since we are writing tests after the code, we need to come up with many scenarios for which our method may fail. The bad extensions will be flagged. But what about different variety of good ones. Will they all pass? The below code will give an idea:
            @Html.DisplayCode(@"
using NUnit.Framework;

namespace LogAn.UnitTests
{
    [TestFixture]
    public class LogAnalyzerTests
    {
        [Test]
        public void IsValidLogFileName_BadExtension_ReturnsFalse()
        {
            //Arrange
            LogAnalyzer analyzer = new LogAnalyzer();

            //Act
            bool result = analyzer.IsValidLogFileName(""filewithbadextension.foo"");

            //Assert
            Assert.False(result);
        }

        [Test]
        public void IsValidLogFileName_GoodExtensionLowerCase_ReturnsTrue()
        {
            //Arrange
            LogAnalyzer analyzer = new LogAnalyzer();

            //Act
            bool result = analyzer.IsValidLogFileName(""filewithgoodextension.slf"");

            //Assert
            Assert.True(result);
        }

        [Test]
        public void IsValidLogFileName_GoodExtensionUpperCase_ReturnsTrue()
        {
            //Arrange
            LogAnalyzer analyzer = new LogAnalyzer();

            //Act
            bool result = analyzer.IsValidLogFileName(""filewithgoodextension.SLF"");

            //Assert
            Assert.True(result);
        }
    }
}

", "c#")
        </p>
        <p>Before even we run our test in the NUnit UI, notice it has already picked up the new tests when we built our solution</p>
        <p>
            <img src="~/Content/Images/testing/16.png" />
        </p>
        <p>
            <img src="~/Content/Images/testing/17.png" />
        </p>
        <p>
            Notice our test fail for <code>IsValidLogFileName_GoodExtensionLowerCase_ReturnsTrue</code>. This only indicates that you have to test if the file extension is bad, but also test for different kinds of correct file extension. Let's fix our code.
            @Html.DisplayCode(@"

namespace LogAn
{
    public class LogAnalyzer
    {
        public bool IsValidLogFileName(string fileName)
        {
            if (!fileName.EndsWith("".SLF"", System.StringComparison.CurrentCultureIgnoreCase))
            {
                return false;
            }
            return true;
        }
    }
}

", "c#")
        </p>
        <p>
            <img src="~/Content/Images/testing/18.png" />
        </p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">From red to green: Passing the Tests</div>
    </div>
    <div class="panel-body">
        <ul>
            <li>If all pass, green. If one fail, red</li>
            <li>Tests will also fail when an exception occurs</li>
            <li>
                Speaking of exceptions, you’ll also see later in this chapter a form of test that
                expects an exception to be thrown from some code, as a specific result or behavior.
                Those tests will fail if an exception is not thrown.
            </li>
        </ul>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Test Code Styling</div>
    </div>
    <div class="panel-body">
        Notice that the test i am writing look different from usual code
        <ul>
            <li>
                The test name can be too long
            </li>
            <li>Separate out Arrange/Act/Assert</li>
        </ul>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Refactoring to parameterized tests</div>
    </div>
    <div class="panel-body">
        <p>
            NUnit's feature <em>parameterized tests</em>. To use it take one of the existing test methods that look exactly the same as the others.
            <ul>
                <li>Replace the <code>[Test]</code> attribute with the <code>[TestCase]</code> attribute.</li>
                <li>Extract all the hardcoded values the test is using into parameters for the test method</li>
                <li>Move the values you had before into the braces of the <code>[TestCase(param1, param2,...)]</code> attribute.</li>
                <li>Rename this test method to a more generic name</li>
                <li>Add a <code>[TestCase(...)]</code> attribute on this same test method for each of the tests you want to merge into this test method, using the other test's values</li>
                <li>Remove the other tests so you're left with just one test method that has multiple <code>[TestCase]</code> attributes</li>
            </ul>
        </p>
        <p>
            @Html.DisplayCode(@"
using NUnit.Framework;

namespace LogAn.UnitTests
{
    [TestFixture]
    public class LogAnalyzerTests
    {
        [Test]
        public void IsValidLogFileName_BadExtension_ReturnsFalse()
        {
            //Arrange
            LogAnalyzer analyzer = new LogAnalyzer();

            //Act
            bool result = analyzer.IsValidLogFileName(""filewithbadextension.foo"");

            //Assert
            Assert.False(result);
        }

        [TestCase(""filewithgoodextension.SLF"")]
        [TestCase(""filewithgoodextension.slf"")]
        public void IsValidLogFileName_ValidExtensions_ReturnsTrue(string file)
        {
            //Arrange
            LogAnalyzer analyzer = new LogAnalyzer();

            //Act
            bool result = analyzer.IsValidLogFileName(file);

            //Assert
            Assert.False(result);
        }
    }
}

", "c#")
        </p>
        <p>
            Let's also refactor the negative test, so the code will finally look like. Notice the test method name, another parameter and the Assert statement.
            @Html.DisplayCode(@"
using NUnit.Framework;

namespace LogAn.UnitTests
{
    [TestFixture]
    public class LogAnalyzerTests
    {
        [TestCase(""filewithgoodextension.SLF"", true)]
        [TestCase(""filewithgoodextension.slf"", true)]
        [TestCase(""filewithbadextension.foo"", false)]
        public void IsValidLogFileName_VariousExtensions_ReturnsTrue(string file, bool expected)
        {
            //Arrange
            LogAnalyzer analyzer = new LogAnalyzer();

            //Act
            bool result = analyzer.IsValidLogFileName(file);

            //Assert
            Assert.AreEqual(expected, result);
        }
    }
}

", "c#")
        </p>
        <p>Let's run this test now.</p>
        <p>
            <img src="../../Content/Images/testing/19.png" alt="" />
        </p>
        <p>
            <img src="../../Content/Images/testing/20.png" alt="" />
        </p>
        <p>Readability: With this one test method, you got rid of multiple versions of similar tests. But notice how the name of the test has become so generic that it's hard to figure out what makes the difference between valid and invalid.</p>
        <p>Maintainabiliti: Notice now we have just one test to maintain, but it can not be 1 big test.</p>
        <p></p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Setup and teardown</div>
    </div>
    <div class="panel-body">
        We have how to run a unit test. Now, we will look at how to set up the initial state for each test and how to remove any garbage that's left by your test.
        <p>When a test ends, the state for that test should be such that it has never ran before. So all the instances of data have to be destroyed.</p>
        <p>Each test should be independent</p>
        <p>
            Attributes to be used for this
            <ul>
                <li>
                    <code>[SetUp]</code>: can be put on a method, it causes NUnit to run that setup method each time it runs any of the tests in your classes.
                </li>
                <li><code>[TearDown]</code>: This attrubute denotes a method to be executed once after each test in your class has executed</li>
            </ul>
        </p>
        <p>
            @Html.DisplayCode(@"
using NUnit.Framework;

namespace LogAn.UnitTests
{
    [TestFixture]
    public class LogAnalyzerTests
    {

        private LogAnalyzer m_analyzer = null;

        [SetUp]
        public void Setup()
        {
            m_analyzer = new LogAnalyzer();
        }

        [TestCase(""filewithgoodextension.SLF"", true)]
        [TestCase(""filewithgoodextension.slf"", true)]
        [TestCase(""filewithbadextension.foo"", false)]
        public void IsValidLogFileName_VariousExtensions_ReturnsTrue(string file, bool expected)
        {
            //Arrange
            LogAnalyzer analyzer = new LogAnalyzer();

            //Act
            bool result = analyzer.IsValidLogFileName(file);

            //Assert
            Assert.AreEqual(expected, result);
        }

        [TearDown]
        public void Teardown()
        {
            //the line below is included to show an anti pattern.
            //This isn't really needed. Don't do it in real life.
            m_analyzer = null;
        }
    }
}

", "c#")
        </p>
        <p>
            <ul>
                <li>Think of the setup and teardown methods as constructors and destructors for the tests in your class</li>
                <li>You can have only one of these in your Test Class</li>
            </ul>
        </p>
        <p>In real life, do not use the setup method to <em>initialize instances</em>. Use factory methods instead.</p>
        <p>
            We also have <code>[TestFixtureSetUp]</code> &amp; <code>[TestFixtureTearDown]</code> for a class level setup and teardown. But this means that you might be sharing state between tests.
        </p>
        <p>We almost <em>never, ever</em> use <code>[TearDown]</code>, <code>[TestFixtureSetUp]</code> &amp; <code>[TestFixtureTearDown]</code>. If you do, you're very likely writing an integration test where you're touching the filesystem or database, and you need to clean up the disk or the DB after the tests</p>
        <p>The only time it makes sense to use a <code>[TearDown]</code> method in unit tests, is when you need to "reset" the state of a static variable or singleton in memory between tests.</p>
        <p>In case you want to do integration tests, do that in a separate project</p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Checking for expected exceptions</div>
    </div>
    <div class="panel-body">
        One common testing scenario is making sure that correct exception is thrown from the tested method when it should be.
        <p>
            Let's assume that your method should throw an <code>ArgumentException</code> when you send in an empty filename. if your code doesn't throw an exception, it means your test should fail.
        </p>
        <p>
            @Html.DisplayCode(@"
using System;
namespace LogAn
{
    public class LogAnalyzer
    {
        public bool IsValidLogFileName(string fileName)
        {
            if (string.IsNullOrEmpty(fileName))
            {
                throw new ArgumentException(""filename has to be provided"");
            }

            if (!fileName.EndsWith("".SLF"", System.StringComparison.CurrentCultureIgnoreCase))
            {
                return false;
            }
            return true;
        }
    }
}

", "c#")
        </p>
        <p>Let's see how to do this by a way, which we shouldn't do</p>
        <p>
            @Html.DisplayCode(@"
using NUnit.Framework;
using System;

namespace LogAn.UnitTests
{
    [TestFixture]
    public class LogAnalyzerTests
    {

        private LogAnalyzer m_analyzer = null;

        [SetUp]
        public void Setup()
        {
            m_analyzer = MakeAnalyzer();
        }

        [TestCase(""filewithgoodextension.SLF"", true)]
        [TestCase(""filewithgoodextension.slf"", true)]
        [TestCase(""filewithbadextension.foo"", false)]
        public void IsValidLogFileName_VariousExtensions_ReturnsTrue(string file, bool expected)
        {
            //Arrange
            LogAnalyzer analyzer = new LogAnalyzer();

            //Act
            bool result = analyzer.IsValidLogFileName(file);

            //Assert
            Assert.AreEqual(expected, result);
        }

        [ExpectedException(typeof(ArgumentException), ExpectedMessage=""filename has to be provided"")]
        public void IsValidFileName_EmptyFileName_ThrowsException()
        {
            m_analyzer.IsValidLogFileName(string.Empty);
        }

        //Factory
        private LogAnalyzer MakeAnalyzer()
        {
            return new LogAnalyzer();
        }
    }
}

", "c#")
        </p>
        <p><img src="../../Content/Images/testing/21.png" alt="" /></p>
        <p>
            See the code again
            <ul>
                <li>Expected value is provided in the attribute</li>
                <li>No explicit Assert Call(the <code>[ExpectedException]</code> attribute contians the assert within it)</li>
                <li>End result is not used</li>
            </ul>
        </p>
        <p>How it works is, this attribute tells the test runner to wrap the execution of this whole method in a big <code>try catch</code> block and fail the test if nothing was <code>catch</code>ed. The problem with this can be that you won't know <em>which</em> line threw the exception, and your test will pass, even though some other exception occured which threw the same exception you expected. Your logic that was intended to be tested didn't get tested. <em><strong>So try not to use it</strong></em></p>
        <p>Instead use <code>@Html.Raw(Html.Encode("Assert.Catch<T>(delegate)"))</code></p>
        <p>
            @Html.DisplayCode(@"
using NUnit.Framework;
using System;

namespace LogAn.UnitTests
{
    [TestFixture]
    public class LogAnalyzerTests
    {

        private LogAnalyzer m_analyzer = null;


        [TestCase(""filewithgoodextension.SLF"", true)]
        [TestCase(""filewithgoodextension.slf"", true)]
        [TestCase(""filewithbadextension.foo"", false)]
        public void IsValidLogFileName_VariousExtensions_ReturnsTrue(string file, bool expected)
        {
            //Arrange
            LogAnalyzer analyzer = new LogAnalyzer();

            //Act
            bool result = analyzer.IsValidLogFileName(file);

            //Assert
            Assert.AreEqual(expected, result);
        }

        [Test]
        public void IsValidFileName_EmptyFileName_ThrowsException()
        {
            m_analyzer = MakeAnalyzer();

            var expected = Assert.Catch<Exception>(()=>m_analyzer.IsValidLogFileName(String.Empty));

            StringAssert.Contains(""filename has to be provided"", expected.Message);
        }

        //Factory
        private LogAnalyzer MakeAnalyzer()
        {
            return new LogAnalyzer();
        }
    }
}

", "c#")
        </p>
        <p>
            There are a lot of changes here:
            <ul>
                <li><code>[ExpectedException]</code> is gone.</li>
                <li>Use of <code>@Html.Raw(Html.Encode("Assert.Catch<T>"))</code> that takes no arguments</li>
                <li><code>Assert.Catch</code> returns the instance of the exception object that was thrown inside the lambda. This allows you to later assert on that exception object</li>
                <li><code>StringAssert</code> makes testing with strings more readable</li>
                <li><code>StringAssert.Contains</code> is used just to check if the message contains a string you are looking for. Contains is used because you never know if a line break comes along with your string.</li>
            </ul>
        </p>
        <p>Other ways of Asserting for Exceptions is NUnit's fluent syntax. Documentation available at <a href="http://nunit.com">nunit.com</a></p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Ignoring Tests</div>
    </div>
    <div class="panel-body">
        Use the <code>[Ignore]</code> attribute on tests that are broken because of a problem in the test, not in the code. This should be rare!
        <p>
            @Html.DisplayCode(@"
using NUnit.Framework;
using System;

namespace LogAn.UnitTests
{
    [TestFixture]
    public class LogAnalyzerTests
    {

        private LogAnalyzer m_analyzer = null;

        [Ignore]
        [TestCase(""filewithgoodextension.SLF"", true)]
        [TestCase(""filewithgoodextension.slf"", true)]
        [TestCase(""filewithbadextension.foo"", false)]
        public void IsValidLogFileName_VariousExtensions_ReturnsTrue(string file, bool expected)
        {
            //Arrange
            LogAnalyzer analyzer = new LogAnalyzer();

            //Act
            bool result = analyzer.IsValidLogFileName(file);

            //Assert
            Assert.AreEqual(expected, result);
        }

        [Test]
        public void IsValidFileName_EmptyFileName_ThrowsException()
        {
            m_analyzer = MakeAnalyzer();

            var expected = Assert.Catch<Exception>(()=>m_analyzer.IsValidLogFileName(String.Empty));

            StringAssert.Contains(""filename has to be provided"", expected.Message);
        }

        //Factory
        private LogAnalyzer MakeAnalyzer()
        {
            return new LogAnalyzer();
        }
    }
}

", "c#")
        </p>
        <p><img src="../../Content/Images/testing/22.png" alt="" /></p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Setting Test Categories</div>
    </div>
    <div class="panel-body">
        <p>
            @Html.DisplayCode(@"
using NUnit.Framework;
using System;

namespace LogAn.UnitTests
{
    [TestFixture]
    public class LogAnalyzerTests
    {

        private LogAnalyzer m_analyzer = null;

        [Category(""Fast Tests"")]
        [TestCase(""filewithgoodextension.SLF"", true)]
        [TestCase(""filewithgoodextension.slf"", true)]
        [TestCase(""filewithbadextension.foo"", false)]
        public void IsValidLogFileName_VariousExtensions_ReturnsTrue(string file, bool expected)
        {
            //Arrange
            LogAnalyzer analyzer = new LogAnalyzer();

            //Act
            bool result = analyzer.IsValidLogFileName(file);

            //Assert
            Assert.AreEqual(expected, result);
        }

        [Test]
        public void IsValidFileName_EmptyFileName_ThrowsException()
        {
            m_analyzer = MakeAnalyzer();

            var expected = Assert.Catch<Exception>(()=>m_analyzer.IsValidLogFileName(String.Empty));

            StringAssert.Contains(""filename has to be provided"", expected.Message);
        }

        //Factory
        private LogAnalyzer MakeAnalyzer()
        {
            return new LogAnalyzer();
        }
    }
}

", "c#")
        </p>
        <p><img src="../../Content/Images/testing/23.png" alt="" /></p>
        <p><img src="../../Content/Images/testing/24.png" alt="" /></p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Testing results that are system state changes instead of return values</div>
    </div>
    <div class="panel-body">
        <p>This is the second type of end result that we expect</p>
        <blockquote>
            <p><strong>Definition</strong>: <em>State-based testing</em>(also called <em>state verification</em>) determines whether the exercised method worked correctly by examining the changed behavior of the system under test and its dependencies after the method is called.</p>
        </blockquote>
        <p>If the system acts exactly the same as it did before, then you didn't really change its state, or there's a bug.</p>
        <p>
            @Html.DisplayCode(@"
using System;
namespace LogAn
{
    public class LogAnalyzer
    {
        public bool WasLastFileNameValid { get; set; }

        public bool IsValidLogFileName(string fileName)
        {
            WasLastFileNameValid = false; // Changes the state of the system
            if (string.IsNullOrEmpty(fileName))
            {
                throw new ArgumentException(""filename has to be provided"");
            }

            if (!fileName.EndsWith("".SLF"", System.StringComparison.CurrentCultureIgnoreCase))
            {
                return false;
            }

            WasLastFileNameValid = true; //Changes the state of the system
            return true;
        }
    }
}

", "c#")
        </p>
        <p><code>WasLastFileNameValid</code> keeps the state of the system. You can't simply test this functionality by writing a test that gets a return value from a method.</p>
        <p>
            First, you have to identify the unit of work you're testing. Is it in the new property called <code>WasLastFileNameValid</code>? Partly. It's also in the <code>IsValidLogFileName</code> method, so your test should start with the name of that method because that's the unit of work you invoke publicly to change the state of the system. The following code shows a simple test to see if the outcome is remembered.
        </p>
        <p>
            @Html.DisplayCode(@"
[Test]
        public void IsValidFileName_WhenCalled_ChangesWasLastFileNameValid()
        {
            LogAnalyzer la = MakeAnalyzer();

            la.IsValidLogFileName(""badname.foo"");

            Assert.False(la.WasLastFileNameValid);
        }
", "c#")
        </p>
        <p>Below is a better test that tests both the positive and the negative</p>
        <p>
            @Html.DisplayCode(@"
[TestCase(""badfile.foo"", false)]
[TestCase(""goodfile.slf"", true)]
public void IsValidFileName_WhenCalled_ChangesWasLastFileNameValid(string file, bool expected)
{
    LogAnalyzer la = MakeAnalyzer();

    la.IsValidLogFileName(file);

    Assert.AreEqual(expected, la.WasLastFileNameValid);
}
", "c#")
        </p>
        <p>
            Some naming conventions
            <ul>
                <li><code>ByDefault</code> can be used when there's an expected return value with no prior action.</li>
                <li><code>WhenCalled</code> or <code>Always</code> can be used in the second or third kind of unit of work results(change state or call a third party) when the state change is done with no prior configuration or when the third-party call is done with no prior configuration; examples: <code>Sum_WhenCalled_CallsTheLogger</code>, <code>Sum_Always_CallsTheLogger</code></li>
            </ul>
        </p>

        <p>
            So far, so good. But what happens when the method you’re testing depends on an
            external resource, such as the filesystem, a database, a web service, or anything else
            that’s hard for you to control? And how do you test the third type of result for a unit of work - a call to a third party? That’s when you start creating test stubs, fake objects, and mock objects, which are discussed in the next few sections.
        </p>
    </div>
</div>