@{
    ViewBag.Title = "Generics";
}

<h2>Generics</h2>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">The Buffer Problem</div>
    </div>
    <div class="panel-body">
        @Html.DisplayCode(@"
namespace DataStructures
{
    public class CircularBuffer
    {
        private double[] _buffer;
        public int _start;
        public int _end;
        public CircularBuffer(int capacity)
        {
            _buffer = new double[capacity + 1];
            _start = 0;
            _end = 0;
        }

        public void Write(double value)
        {
            _buffer[_end] = value;
            _end = (_end + 1) % _buffer.Length;
            if (_end == _start)
            {
                _start = (_start + 1) % _buffer.Length;
            }
        }

        public double Read()
        {
            var result = _buffer[_start];
            _buffer[_start] = 0.0;
            if (_start == _end)
            {
                return 0.0;
            }

            _start = (_start + 1) % _buffer.Length;

            return result;
        }
    }
}

", "c#")
        <p>Circular buffer is a data stucture where a size is assigned to it. It follows a queue. You start writing values to the buffer, it gets added at the end. You read values, it reads from the start. In case of overflow, the first value is flushed out, all the values shift in front to make room for the lates incoming value at the back. A Circular buffer is generally used to stream audio data.</p>
        <p>
            Let's see a case of a buffer with a capacity of 3 elements. Notice the circular buffer we created only accepts a <code>double</code>. Upon reading the buffer, only last 3 values are fetched. On reading more it returns 0.0;
        </p>
        <p>
            @Html.DisplayCode(@"
using DataStructures;
using System;

namespace Client
{
    class Program
    {
        static void Main(string[] args)
        {
            CircularBuffer cb = new CircularBuffer(capacity: 3);
            cb.Write(1);
            cb.Write(2);
            cb.Write(3);
            cb.Write(4);
            cb.Write(5);

            Console.WriteLine(cb.Read());
            Console.WriteLine(cb.Read());
            Console.WriteLine(cb.Read());

            //Reading this would result in a default value of a double i.e. 0.0
            Console.WriteLine(cb.Read());

            Console.ReadLine();
        }
    }
}

", "c#")
        </p>
        <p>
            <img src="../../Content/Images/Generics/1.png" alt="" />
        </p>
        <p>
            The <em><strong>Problem</strong></em> here is that it only accepts <code>double</code>. The <code>Write</code> method only accepts a <code>double</code>, and the <code>Read</code> method only returns a <code>double</code>. I want to use this Circular buffer for other datatypes like <code>Byte</code>, <code>String</code> etc. Let's see a couple of solutions in the next section that do not involve generics.
        </p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">The Object Solution</div>
    </div>
    <div class="panel-body">
        <p>
            What we are going to do is that in the Circular buffer class, we will replace all the <code>double</code> to <code>object</code>. So now, my buffer stores an array of objects, it Writes an object and Reads an object. Let's see how the code will look like.
        </p>
        <p>
            @Html.DisplayCode(@"
namespace DataStructures
{
    public class CircularBuffer
    {
        private object[] _buffer;
        public int _start;
        public int _end;
        public CircularBuffer(int capacity)
        {
            _buffer = new object[capacity + 1];
            _start = 0;
            _end = 0;
        }

        public void Write(object value)
        {
            _buffer[_end] = value;
            _end = (_end + 1) % _buffer.Length;
            if (_end == _start)
            {
                _start = (_start + 1) % _buffer.Length;
            }
        }

        public object Read()
        {
            var result = _buffer[_start];
            _buffer[_start] = 0.0;
            if (_start == _end)
            {
                return 0.0;
            }

            _start = (_start + 1) % _buffer.Length;

            return result;
        }
    }
}

", "c#")
        </p>
        <p>
            And not this allows me to Write <code>String</code> in the buffer. Basically it allows me to write anything(since every type has a base class of <code>object</code>). Let's see that in action. We will now enter <code>String</code>. Note, <code>double</code> still works.
        </p>
        <p>
            <img src="../../Content/Images/Generics/1.png" alt="" />
        </p>
        <p>
            @Html.DisplayCode(@"
using DataStructures;
using System;

namespace Client
{
    class Program
    {
        static void Main(string[] args)
        {
            CircularBuffer cb = new CircularBuffer(capacity: 3);
            cb.Write(""1"");
            cb.Write(""2"");
            cb.Write(""3"");
            cb.Write(""4"");
            cb.Write(""5"");

            Console.WriteLine(cb.Read());
            Console.WriteLine(cb.Read());
            Console.WriteLine(cb.Read());

            //Reading this would result in a default value of a double i.e. 0.0
            Console.WriteLine(cb.Read());

            Console.ReadLine();
        }
    }
}

", "c#")
        </p>
        <p><img src="../../Content/Images/Generics/1.png" alt="" /></p>
        <p>
            Notice this works because <code>Console.WriteLine</code> knows how to implicitly convert a <code>double</code> to a <code>String</code>(This is what was happening earlier. Not a big deal!) just for the sake of displaying on the Console. And this time it is just displaying <code>String</code> itself.
        </p>
        <p>
            Let's have a couple of different things in the buffer now, let's have a combination of <code>String</code> which is actually a small word that can not be converted to a <code>double</code> and a <code>double</code> value.
        </p>
        <p>
            @Html.DisplayCode(@"
using DataStructures;
using System;

namespace Client
{
    class Program
    {
        static void Main(string[] args)
        {
            CircularBuffer cb = new CircularBuffer(capacity: 3);
            cb.Write(""1"");
            cb.Write(""2"");
            cb.Write(""3"");
            cb.Write(""Hello World!"");
            cb.Write(""5"");

            Console.WriteLine(cb.Read());
            Console.WriteLine(cb.Read());
            Console.WriteLine(cb.Read());

            //Reading this would result in a default value of a double i.e. 0.0
            Console.WriteLine(cb.Read());

            Console.ReadLine();
        }
    }
}

", "c#")
        </p>
        <p>
            <img src="../../Content/Images/Generics/2.png" alt="" />
        </p>
        <p>
            So far, so good. Notice the operation being done on the buffer here is just reading and writing. <code>Console.WriteLine</code> does a pretty good job here to convert everything to a <code>String</code> for displaying. Let's say we come back to our Writing of only some <code>String</code> values which can be converted to <code>double</code>. And this time we want to do some operation like addition on the buffer.
        </p>
        <p>
            @Html.DisplayCode(@"
using DataStructures;
using System;

namespace Client
{
    class Program
    {
        static void Main(string[] args)
        {
            CircularBuffer cb = new CircularBuffer(capacity: 3);
            cb.Write(""1"");
            cb.Write(""2"");
            cb.Write(""3"");
            cb.Write(""4"");
            cb.Write(""5"");

            double sum = 0;
            for (int i = 0; i < 3; i++)
            {
                sum += cb.Read();
            }

            Console.WriteLine(sum);

            Console.ReadLine();
        }
    }
}

", "c#")
        </p>
        <p>The compiler throws error here saying :</p>
        <p>
            <img src="../../Content/Images/Generics/3.png" alt="" />
        </p>
        <p>
            Ok, no problem, we will do a type conversion and the problem will be fixed.
        </p>
        <p>
            @Html.DisplayCode(@"
using DataStructures;
using System;

namespace Client
{
    class Program
    {
        static void Main(string[] args)
        {
            CircularBuffer cb = new CircularBuffer(capacity: 3);
            cb.Write(""1"");
            cb.Write(""2"");
            cb.Write(""3"");
            cb.Write(""4"");
            cb.Write(""5"");

            double sum = 0;
            for (int i = 0; i < 3; i++)
            {
                sum += Convert.ToDouble(cb.Read());
            }

            Console.WriteLine(sum);

            Console.ReadLine();
        }
    }
}

", "c#")
        </p>
        <p>
            <img src="../../Content/Images/Generics/4.png" alt="" />
        </p>
        <p>
            There are some points to notice
            <ul>
                <li>It doesn't look correct that we have to convert the type everytime we want to use it. Why shouldn't the Read method return a double.</li>
                <li>
                    And since the buffer is an <code>object</code> array. Its possible to write anything in it. See the example above where we entered "Hello World!" in the buffer. Imagine some one doing a Sum operation on that and trying to convert "Hello World!" to a <code>double</code>!!. Of course that would throw an exception.
                </li>
                <li>The <code>object</code> array will not be type safe.</li>
            </ul>
        </p>
        <p>
            There can be an argument upon let's check the value before we add it to the <code>sum</code> variable using <code>value is double</code> in an <code>if</code> condition. First, do we want to keep a lot of different types in a single memory location to use? Second, everytime we store something in the <code>object</code> array, that type is <em><strong>boxed</strong></em> and when read, it is <em><strong>unboxed</strong></em>. Boxing and Unboxing requires separate allocation of memory in the managed heap and it makes our programs slower(obviously because there are extra steps to work with a value, which could have been much easier when using them as their direct types.)
        </p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Copy and Paste Solution</div>
    </div>
    <div class="panel-body">
        <p>
            All right so we need it for <code>String</code> too. No Problem, just copy paste the code for <code>double</code> and create a new class.
        </p>
        <p>
            @Html.DisplayCode(@"
namespace DataStructures
{
    public class CircularBufferString
    {
        private String[] _buffer;
        public int _start;
        public int _end;
        public CircularBufferString(int capacity)
        {
            _buffer = new String[capacity + 1];
            _start = 0;
            _end = 0;
        }

        public void Write(String value)
        {
            _buffer[_end] = value;
            _end = (_end + 1) % _buffer.Length;
            if (_end == _start)
            {
                _start = (_start + 1) % _buffer.Length;
            }
        }

        public String Read()
        {
            var result = _buffer[_start];
            _buffer[_start] = 0.0;
            if (_start == _end)
            {
                return 0.0;
            }

            _start = (_start + 1) % _buffer.Length;

            return result;
        }
    }
}

", "c#")
        </p>
        <p>Here we go, we have it for strings too. But wait, i also wanted it for <code>int</code>!! How many times are you going to copy and paste??</p>
        <p>If you notice the above code, we just changed the Type <code>double</code> to <code>String</code> (forget the class name changing)</p>.
        <p>
            What if we could have a placeholder like <code>T</code> instead of <code>double</code> or <code>String</code>. See an example below:
        </p>
        <p>
            @Html.DisplayCode(@"
namespace DataStructures
{
    public class CircularBufferString
    {
        private T[] _buffer;
        public int _start;
        public int _end;
        public CircularBufferString(int capacity)
        {
            _buffer = new String[capacity + 1];
            _start = 0;
            _end = 0;
        }

        public void Write(T value)
        {
            _buffer[_end] = value;
            _end = (_end + 1) % _buffer.Length;
            if (_end == _start)
            {
                _start = (_start + 1) % _buffer.Length;
            }
        }

        public T Read()
        {
            var result = _buffer[_start];
            _buffer[_start] = 0.0;
            if (_start == _end)
            {
                return 0.0;
            }

            _start = (_start + 1) % _buffer.Length;

            return result;
        }
    }
}

", "c#")
        </p>
        <p>Notice that we are creating a type <code>T</code> when declaring the array, when Writing and when Reading. We want to declare this type <code>T</code> sometime later after compilation.</p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Generics</div>
    </div>
    <div class="panel-body">
        <p>
            The idea of Generics originated because we wanted to reuse some code that is needed by different types. And we don't want <code>object</code> that can be used <em>instead</em> of any type. We want the Type itself. In a type safe manner. So we write a code:
            <ul>
                <li>That can defer the type specification to the client who uses that code.</li>
                <li>The Internal algorithms of operation are independent of the Type. For example the logic for enumerating over a list of <code>int</code> or <code>string</code> should be same. </li>
            </ul>
        </p>
        <p>
            This is how it looks:
            @Html.DisplayCode(@"
public class CircularBuffer<T>
{
    private T[] _buffer;

    //...
}
", "c#")
        </p>
        <p>
            Notice <code>@Html.Raw(Html.Encode("CircularBuffer<T>"))</code>. This is the <em>constructor</em> for a class definition. <code>@Html.Raw(Html.Encode("<T>"))</code> is brackets accepting a list of parameters. We CAN have multiple parameters being passed here. These parameters are nothing but a <code>Type</code>. <code>T</code> for <code>Type</code>. <code>@Html.Raw(Html.Encode("CircularBuffer<T>"))</code> is now called <em><strong>CircularBuffer of T</strong></em>
        </p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">A Generic Circular Buffer</div>
    </div>
    <div class="panel-body">
        @Html.DisplayCode(@"
namespace DataStructures
{
    public class CircularBuffer<T>
    {
        private T[] _buffer;
        public int _start;
        public int _end;
        public CircularBuffer(int capacity)
        {
            _buffer = new T[capacity + 1];
            _start = 0;
            _end = 0;
        }

        public void Write(T value)
        {
            _buffer[_end] = value;
            _end = (_end + 1) % _buffer.Length;
            if (_end == _start)
            {
                _start = (_start + 1) % _buffer.Length;
            }
        }

        public T Read()
        {
            var result = _buffer[_start];
            _start = (_start + 1) % _buffer.Length;

            return result;
        }
    }
}

", "c#")
        <p>
            @Html.DisplayCode(@"
using DataStructures;
using System;

namespace Client
{
    class Program
    {
        static void Main(string[] args)
        {
            var cb = new CircularBuffer<string>(capacity: 3);
            cb.Write(""Hello"");
            cb.Write(""I"");
            cb.Write(""Am"");
            cb.Write(""Suyash"");

            Console.WriteLine(cb.Read());
            Console.WriteLine(cb.Read());
            Console.WriteLine(cb.Read());


            Console.ReadLine();
        }
    }
}

", "c#")
        </p>
        <p>
            <img src="../../Content/Images/Generics/5.png" alt="" />
        </p>
        <p>Let's proove that it is type safe. Try to insert another type and see it throw a compiler error</p>
        <p>
            @Html.DisplayCode(@"
using DataStructures;
using System;

namespace Client
{
    class Program
    {
        static void Main(string[] args)
        {
            var cb = new CircularBuffer<string>(capacity: 3);
            cb.Write(""Hello"");
            cb.Write(""I"");
            cb.Write(""Am"");
            cb.Write(""Suyash"");
            cb.Write(1);

            Console.WriteLine(cb.Read());
            Console.WriteLine(cb.Read());
            Console.WriteLine(cb.Read());


            Console.ReadLine();
        }
    }
}

", "c#")
        </p>
        <p>
            <img src="../../Content/Images/Generics/6.png" alt="" />
        </p>
        <p>
            But change it to a Circular buffer of <code>int</code>, change all the values to <code>int</code> and see it work.
            @Html.DisplayCode(@"
using DataStructures;
using System;

namespace Client
{
    class Program
    {
        static void Main(string[] args)
        {
            var cb = new CircularBuffer<int>(capacity: 3);
            cb.Write(1);
            cb.Write(2);
            cb.Write(3);
            cb.Write(4);
            cb.Write(5);

            Console.WriteLine(cb.Read());
            Console.WriteLine(cb.Read());
            Console.WriteLine(cb.Read());


            Console.ReadLine();
        }
    }
}

", "c#")
        </p>
        <p>
            <img src="../../Content/Images/Generics/7.png" alt="" />
        </p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Terminology</div>
    </div>
    <div class="panel-body">
        <ul>
            <li>A class with ended with angle brackets is called a <em><strong>Generic Class</strong></em></li>
            <li>You can also have Generic Interfaces, Generic Delegates, Generic Structs.</li>
            <li><code>T</code> is what we call a <em><strong>Type Parameter</strong></em></li>
            <li><code>T</code> is just conventional you can use <code>X</code>. Basically any name.</li>
            <li>You can have multiple Type Parameter</li>
            <li><code>@Html.Raw(Html.Encode("var buffer = new CircularBuffer<double>();"))</code>. Here <code>double</code> is the <em><strong>Type Argument</strong></em>. Only a <code>double</code> can be used for this.</li>
            <li>When we create Generic Type, passing in a Type Argument, there is a new class definition thats created behind the scenes and ready to be used. <code>@Html.Raw(Html.Encode("CircularBuffer<double>"))</code> is a new Type available to use.</li>
            <li>
                <img src="../../Content/Images/Generics/8.png" alt="" />
            </li>
        </ul>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Generic Collections</div>
    </div>
    <div class="panel-body">
        <p>Generics and Collections work well together because collection is all about managing and organizing data and quite often you want to organize a specific type of data like keep a list of employee objects around and the list represents a department, a department of employees. Different collections have different weaknesses and capabilities so its good to know about all the options</p>
        <ul>
            <li>Array</li>
            <li>List, Capacity</li>
            <li>Queue, Enqueue, Dequeue, Peek, Contains</li>
            <li>Stack, Push, Pop</li>
            <li>LinkedList</li>
            <li>Dictionary</li>
            <li>SortedList, SortedDictionary, SortedSet</li>
            <li>Concurrent Collections : Multiple writers and readers, thread safe</li>
            <li>Immutable Collections : Thread safe, modifications produce new collections</li>
        </ul>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Generic Classes &amp; Interfaces</div>
    </div>
    <div class="panel-body">
        Let's refactor our Circular buffer a little. Here is the code:
        @Html.DisplayCode(@"
namespace DataStructures
{
    public class CircularBuffer<T>
    {
        private T[] _buffer;
        public int _start;
        public int _end;
        public CircularBuffer(int capacity)
        {
            _buffer = new T[capacity + 1];
            _start = 0;
            _end = 0;
        }

        public void Write(T value)
        {
            _buffer[_end] = value;
            _end = (_end + 1) % _buffer.Length;
            if (_end == _start)
            {
                _start = (_start + 1) % _buffer.Length;
            }
        }

        public T Read()
        {
            var result = _buffer[_start];
            _start = (_start + 1) % _buffer.Length;

            return result;
        }

        public int Capacity
        {
            get { return _buffer.Length; }
        }

        public bool IsEmpty
        {
            get { return _end == _start; }
        }

        public bool IsFull
        {
            get { return (_end + 1) % _buffer.Length == _start; }
        }
    }
}

", "c#")
        <p>
            @Html.DisplayCode(@"
using DataStructures;
using System;

namespace Client
{
    class Program
    {
        static void Main(string[] args)
        {
            var buffer = new CircularBuffer<double>(capacity: 3);


            ProcessInput(buffer);
            ProcessBuffer(buffer);


            Console.ReadLine();
        }

        private static void ProcessBuffer(CircularBuffer<double> buffer)
        {
            var sum = 0.0;
            Console.WriteLine(""Buffer: "");
            while (!buffer.IsEmpty)
            {
                sum += buffer.Read();
            }
            Console.WriteLine(sum);
        }

        private static void ProcessInput(CircularBuffer<double> buffer)
        {
            while (true)
            {
                var value = 0.0;
                var input = Console.ReadLine();

                if (double.TryParse(input, out value))
                {
                    buffer.Write(value);
                    continue;
                }
                break;
            }
        }
    }
}

", "c#")
        </p>
        <p>
            There can be multiple types of such buffers. Let's refactor it out to an interface.
            @Html.DisplayCode(@"
namespace DataStructures
{
    public interface IBuffer<T>
    {
        bool IsEmpty { get; }
        void Write(T value);
        T Read();
    }


    public class CircularBuffer<T> : IBuffer<T>
    {
        private T[] _buffer;
        public int _start;
        public int _end;
        public CircularBuffer(int capacity)
        {
            _buffer = new T[capacity + 1];
            _start = 0;
            _end = 0;
        }

        public void Write(T value)
        {
            _buffer[_end] = value;
            _end = (_end + 1) % _buffer.Length;
            if (_end == _start)
            {
                _start = (_start + 1) % _buffer.Length;
            }
        }

        public T Read()
        {
            var result = _buffer[_start];
            _start = (_start + 1) % _buffer.Length;

            return result;
        }

        public int Capacity
        {
            get { return _buffer.Length; }
        }

        public bool IsEmpty
        {
            get { return _end == _start; }
        }

        public bool IsFull
        {
            get { return (_end + 1) % _buffer.Length == _start; }
        }
    }
}

", "c#")
        </p>
        <p>
            And the Program
            @Html.DisplayCode(@"
using DataStructures;
using System;

namespace Client
{
    class Program
    {
        static void Main(string[] args)
        {
            var buffer = new CircularBuffer<double>(capacity: 3);


            ProcessInput(buffer);
            ProcessBuffer(buffer);


            Console.ReadLine();
        }

        private static void ProcessBuffer(IBuffer<double> buffer)
        {
            var sum = 0.0;
            Console.WriteLine(""Buffer: "");
            while (!buffer.IsEmpty)
            {
                sum += buffer.Read();
            }
            Console.WriteLine(sum);
        }

        private static void ProcessInput(IBuffer<double> buffer)
        {
            while (true)
            {
                var value = 0.0;
                var input = Console.ReadLine();

                if (double.TryParse(input, out value))
                {
                    buffer.Write(value);
                    continue;
                }
                break;
            }
        }
    }
}

", "c#")
        </p>
        <p>
            Now i can use some other buffer instead of Circular Buffer. Let's implement it. and let's circular buffer implement the buffer
            @Html.DisplayCode(@"
using System.Collections.Generic;
namespace DataStructures
{
    public interface IBuffer<T>
    {
        bool IsEmpty { get; }
        void Write(T value);
        T Read();
    }


    public class Buffer<T> : IBuffer<T>
    {

        public Queue<T> _queue = new Queue<T>();

        public virtual bool IsEmpty
        {
            get { return _queue.Count == 0; }
        }

        public virtual void Write(T value)
        {
            _queue.Enqueue(value);
        }

        public virtual T Read()
        {
            return _queue.Dequeue();
        }
    }


    public class CircularBuffer<T> : Buffer<T>
    {
        int _capacity;
        public CircularBuffer(int capacity = 10)
        {
            _capacity = capacity;
        }

        public override void Write(T value)
        {
            base.Write(value);
            if (_queue.Count > _capacity)
            {
                _queue.Dequeue();
            }
        }

        public bool IsFull { get { return _queue.Count == _capacity; } }
    }
}

", "c#")
        </p>

    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title"><code>@Html.Raw(Html.Encode("IEnumerable<T>"))</code></div>
    </div>
    <div class="panel-body">
        <p>
            IEnumerable, IComparer, IEqualityComparer
        </p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Generic Methods</div>
    </div>
    <div class="panel-body">
        <p>
            @Html.DisplayCode(@"
using System.Collections.Generic;
using System.ComponentModel;
namespace DataStructures
{
    public interface IBuffer<T>: IEnumerable<T>
    {
        bool IsEmpty { get; }
        void Write(T value);
        IEnumerable<TOutput> AsEnumerableOf<TOutput>();

        T Read();
    }


    public class Buffer<T> : IBuffer<T>
    {

        public Queue<T> _queue = new Queue<T>();

        public virtual bool IsEmpty
        {
            get { return _queue.Count == 0; }
        }

        public virtual void Write(T value)
        {
            _queue.Enqueue(value);
        }

        public virtual T Read()
        {
            return _queue.Dequeue();
        }

        public IEnumerator<T> GetEnumerator()
        {
            return _queue.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }


        public IEnumerable<TOutput> AsEnumerableOf<TOutput>()
        {
            var converter = TypeDescriptor.GetConverter(typeof(T));
            foreach (var item in _queue)
            {
                var result = converter.ConvertTo(item, typeof(TOutput));
                yield return (TOutput)result;
            }
        }
    }


    public class CircularBuffer<T> : Buffer<T>
    {
        int _capacity;
        public CircularBuffer(int capacity = 10)
        {
            _capacity = capacity;
        }

        public override void Write(T value)
        {
            base.Write(value);
            if (_queue.Count > _capacity)
            {
                _queue.Dequeue();
            }
        }

        public bool IsFull { get { return _queue.Count == _capacity; } }
    }
}

", "c#")
        </p>
        <p>
            On using it, the types which can be converted to each other normally will work fine. But for example if you try to convert a <code>double</code> to a <code>DateTime</code>, an exception is thrown.
        </p>
        <p>A Generic method need not be a part of a Generic class. It can be a part of a Non-Generic Type</p>
        <p>
            Let's move the <code>AsEnumerableOf</code> method in an extension method.
            @Html.DisplayCode(@"
using System.Collections.Generic;
using System.ComponentModel;

namespace DataStructures
{
    public static class BufferExtensions
    {
        public static IEnumerable<TOutput> AsEnumerableOf<T, TOutput>(this IBuffer<T> buffer)
        {
            var converter = TypeDescriptor.GetConverter(typeof(T));
            foreach (var item in buffer)
            {
                TOutput result = (TOutput)converter.ConvertTo(item, typeof(TOutput));
                yield return result;
            }
        }
    }
}

", "c#")
        </p>
        <p>Notice the Class Type parameter is now passed in the Generic Method signature. <code>T</code></p>
        <p>A Type parameter is a part of Generic method signature, if you have another method with the same name and same number of type parameter, the compiler will throw error.</p>
        <p>In case of extension methods, if there is just one parameter, no need to supply the generic type parameter. It will automatically infer.</p>
        <p>
            @Html.DisplayCode(@"
using DataStructures;
using System;

namespace Client
{
    class Program
    {
        static void ConsoleWrite(object data)
        {
            Console.WriteLine(data);
        }
        static void Main(string[] args)
        {
            //var buffer = new CircularBuffer<double>(capacity: 3);
            var buffer = new DataStructures.Buffer<double>();

            ProcessInput(buffer);

            Printer consoleOut = new Printer(ConsoleWrite);
            buffer.Dump(consoleOut);
            //buffer.Dump<double>(consoleOut);
            Console.WriteLine(""---------"");

            var resultInt =  buffer.AsEnumerableOf<double, int>();
            foreach (var item in resultInt)
            {
                Console.WriteLine(item);
            }

            ProcessBuffer(buffer);


            Console.ReadLine();
        }

        private static void ProcessBuffer(IBuffer<double> buffer)
        {
            var sum = 0.0;
            Console.WriteLine(""Buffer: "");
            while (!buffer.IsEmpty)
            {
                sum += buffer.Read();
            }
            Console.WriteLine(sum);
        }

        private static void ProcessInput(IBuffer<double> buffer)
        {
            while (true)
            {
                var value = 0.0;
                var input = Console.ReadLine();

                if (double.TryParse(input, out value))
                {
                    buffer.Write(value);
                    continue;
                }
                break;
            }
        }
    }
}

", "c#")
        </p>

        <p>
            Above example will now be converted to use a generic delegate. Instead of a <code>Printer</code> using an <code>object</code> type, lets defer the type.
        </p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Everyday Delegates</div>
    </div>
    <div class="panel-body">
        <ul>
            <li><code>Func</code></li>
            <li><code>Action</code></li>
            <li><code>Predicate</code></li>
        </ul>
        <p>
            Let's look at <code>Action</code> first. It allows to type a variable that will be a delegate so it points to a method, but that method has to return void. An <code>Action</code> delegate always returns <code>void</code>, but it can take from 0-16 parameters.Those parameters are 0-16 generic Type Arguments. For example <code>@Html.Raw(Html.Encode("Action<double>"))</code> type delegate can only take a method that takes 1 parameter which is of the type <code>double</code> and it has to return <code>void</code>.
        </p>
        <p>
            @Html.DisplayCode(@"
using System;
using System.Collections.Generic;
using System.ComponentModel;

namespace DataStructures
{
    public static class BufferExtensions
    {
        public static void Dump<T>(this IBuffer<T> buffer, Action<T> print)
        {
            foreach (var item in buffer)
            {
                print(item);
            }
        }
        public static IEnumerable<TOutput> AsEnumerableOf<T, TOutput>(this IBuffer<T> buffer)
        {
            var converter = TypeDescriptor.GetConverter(typeof(T));
            foreach (var item in buffer)
            {
                TOutput result = (TOutput)converter.ConvertTo(item, typeof(TOutput));
                yield return result;
            }
        }
    }
}

", "c#")
        </p>
        <p>
            @Html.DisplayCode(@"
using DataStructures;
using System;

namespace Client
{
    class Program
    {
        static void ConsoleWrite(double data)
        {
            Console.WriteLine(data);
        }
        static void Main(string[] args)
        {
            //var buffer = new CircularBuffer<double>(capacity: 3);
            var buffer = new DataStructures.Buffer<double>();

            ProcessInput(buffer);

            Action<double> print = Console.WriteLine;
            buffer.Dump(print);
            //buffer.Dump<double>(consoleOut);
            Console.WriteLine(""---------"");

            var resultInt =  buffer.AsEnumerableOf<double, int>();
            foreach (var item in resultInt)
            {
                Console.WriteLine(item);
            }

            ProcessBuffer(buffer);


            Console.ReadLine();
        }

        private static void ProcessBuffer(IBuffer<double> buffer)
        {
            var sum = 0.0;
            Console.WriteLine(""Buffer: "");
            while (!buffer.IsEmpty)
            {
                sum += buffer.Read();
            }
            Console.WriteLine(sum);
        }

        private static void ProcessInput(IBuffer<double> buffer)
        {
            while (true)
            {
                var value = 0.0;
                var input = Console.ReadLine();

                if (double.TryParse(input, out value))
                {
                    buffer.Write(value);
                    continue;
                }
                break;
            }
        }
    }
}

", "c#")
        </p>
        <p>
            Instead of a Typed delegate such as <code>Console.WriteLine</code>. We can use an anonymous delegate as below:
            @Html.DisplayCode(@"
Action<double> print = delegate(double data)
            {
                Console.WriteLine(data);
            };
", "c#")
        </p>
        <p>
            Another way of writing an anonymous method is to use a lambda expression as below:
            @Html.DisplayCode(@"
Action<double> print = (d) => Console.WriteLine(d);
", "c#")
        </p>
        <p>
            @Html.DisplayCode(@"
using DataStructures;
using System;

namespace Client
{
    class Program
    {
        static void ConsoleWrite(double data)
        {
            Console.WriteLine(data);
        }
        static void Main(string[] args)
        {
            //var buffer = new CircularBuffer<double>(capacity: 3);
            var buffer = new DataStructures.Buffer<double>();

            ProcessInput(buffer);

            //Action<double> print = delegate(double data)
            //{
            //    Console.WriteLine(data);
            //};
            //Action<double> print = (d) => Console.WriteLine(d);
            buffer.Dump(d=>Console.WriteLine(d));
            //buffer.Dump<double>(consoleOut);
            Console.WriteLine(""---------"");

            var resultInt =  buffer.AsEnumerableOf<double, int>();
            foreach (var item in resultInt)
            {
                Console.WriteLine(item);
            }

            ProcessBuffer(buffer);


            Console.ReadLine();
        }

        private static void ProcessBuffer(IBuffer<double> buffer)
        {
            var sum = 0.0;
            Console.WriteLine(""Buffer: "");
            while (!buffer.IsEmpty)
            {
                sum += buffer.Read();
            }
            Console.WriteLine(sum);
        }

        private static void ProcessInput(IBuffer<double> buffer)
        {
            while (true)
            {
                var value = 0.0;
                var input = Console.ReadLine();

                if (double.TryParse(input, out value))
                {
                    buffer.Write(value);
                    continue;
                }
                break;
            }
        }
    }
}

", "c#")
        </p>
        <p>
            @Html.DisplayCode(@"
using DataStructures;
using System;

namespace Client
{
    class Program
    {
        static void ConsoleWrite(double data)
        {
            Console.WriteLine(data);
        }
        static void Main(string[] args)
        {
            //var buffer = new CircularBuffer<double>(capacity: 3);
            var buffer = new DataStructures.Buffer<double>();

            ProcessInput(buffer);

            //Action<double> print = delegate(double data)
            //{
            //    Console.WriteLine(data);
            //};
            Action<bool> print = (d) => Console.WriteLine(d);

            Func<double, double> square = d => d * d;
            Func<double, double, double> add = (x, y) => x + y;
            Predicate<double> isLessThanTen = d => d < 10;

            print(isLessThanTen(square(add(3, 5))));


            buffer.Dump(d=>Console.WriteLine(d));
            //buffer.Dump<double>(consoleOut);
            Console.WriteLine(""---------"");

            var resultInt =  buffer.AsEnumerableOf<double, int>();
            foreach (var item in resultInt)
            {
                Console.WriteLine(item);
            }

            ProcessBuffer(buffer);


            Console.ReadLine();
        }

        private static void ProcessBuffer(IBuffer<double> buffer)
        {
            var sum = 0.0;
            Console.WriteLine(""Buffer: "");
            while (!buffer.IsEmpty)
            {
                sum += buffer.Read();
            }
            Console.WriteLine(sum);
        }

        private static void ProcessInput(IBuffer<double> buffer)
        {
            while (true)
            {
                var value = 0.0;
                var input = Console.ReadLine();

                if (double.TryParse(input, out value))
                {
                    buffer.Write(value);
                    continue;
                }
                break;
            }
        }
    }
}

", "c#")
        </p>
        <p>
            There is one more Generic delegate not used daily but good to talk about. It is the <code>Converter</code> delegate that accepts to type arguments i.e. the "from" type and the "to" type. Let's see the code.
            @Html.DisplayCode(@"
public static IEnumerable<TOutput> Map<T, TOutput>(this IBuffer<T> buffer, Converter<T, TOutput> converter)
        {
            return buffer.Select(x => converter(x));
        }
", "c#")
            @Html.DisplayCode(@"

Converter<double, DateTime> converter = d => new DateTime(2015, 6, 13).AddDays(d);

var resultInDate = buffer.Map<double, DateTime>(converter);

foreach (var item in resultInDate)
{
    Console.WriteLine(item);
}
", "c#")
        </p>
        <p>
            Or
            @Html.DisplayCode(@"
//Converter<double, DateTime> converter = d => new DateTime(2015, 6, 13).AddDays(d);

            var resultInDate = buffer.Map<double, DateTime>(d => new DateTime(2015, 6, 13).AddDays(d));
", "c#")
        </p>
        <p>
            Or considering the fact that lambdas are pretty smart.
            @Html.DisplayCode(@"
//Converter<double, DateTime> converter = d => new DateTime(2015, 6, 13).AddDays(d);

            var resultInDate = buffer.Map(d => new DateTime(2015, 6, 13).AddDays(d));
", "c#")
        </p>
        <p>
            The above code displays that the type arguments are inferred by buffer which is of type <code>double</code> which is an extension method if <code>@Html.Raw(Html.Encode("IBuffer<double>"))</code>. and return type of the lambda which is a <code>DateTime</code>
        </p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Events and Generics</div>
    </div>
    <div class="panel-body">
        <p>
            Let's say we want to raise an event when the circular buffer is full and somthing is being discarded. We want to raise the event showing the discarded value and the new item that is discarding that value.
            @Html.DisplayCode(@"
public class CircularBuffer<T> : Buffer<T>
    {
        int _capacity;
        public CircularBuffer(int capacity = 10)
        {
            _capacity = capacity;
        }

        public override void Write(T value)
        {
            base.Write(value);
            if (_queue.Count > _capacity)
            {
                var discarded = _queue.Dequeue();
                var newItem = value;
                var args = new ItemDiscardedEventArgs<T>(discarded, newItem);
                ItemDiscarded(this, args);
            }
        }

        public event EventHandler<ItemDiscardedEventArgs<T>> ItemDiscarded;

        public bool IsFull { get { return _queue.Count == _capacity; } }
    }
", "c#")
        </p>
        <p>
            The Program
            @Html.DisplayCode(@"
using DataStructures;
using System;

namespace Client
{
    class Program
    {
        static void ConsoleWrite(double data)
        {
            Console.WriteLine(data);
        }
        static void Main(string[] args)
        {
            var buffer = new CircularBuffer<double>(capacity: 3);
            buffer.ItemDiscarded += buffer_ItemDiscarded;

            ProcessInput(buffer);


            ProcessBuffer(buffer);


            Console.ReadLine();
        }

        static void buffer_ItemDiscarded(object sender, ItemDiscardedEventArgs<double> e)
        {
            Console.WriteLine(""Buffer Full. Discarded {0} New Item is {1}"", e.Discarded, e.NewItem);
        }

        private static void ProcessBuffer(IBuffer<double> buffer)
        {
            var sum = 0.0;
            Console.WriteLine(""Buffer: "");
            while (!buffer.IsEmpty)
            {
                sum += buffer.Read();
            }
            Console.WriteLine(sum);
        }

        private static void ProcessInput(IBuffer<double> buffer)
        {
            while (true)
            {
                var value = 0.0;
                var input = Console.ReadLine();

                if (double.TryParse(input, out value))
                {
                    buffer.Write(value);
                    continue;
                }
                break;
            }
        }
    }
}

", "c#")
        </p>
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Generic Constraints</div>
    </div>
    <div class="panel-body">
        Force a type parameter to have certain characteristics
        <ul>
            <li>Be a reference type or value type</li>
            <li>Implement an interface</li>
            <li>Derive from a base class</li>
            <li>Have a default constructor</li>
            <li>Be (or derive from) another generic type parameter</li>
        </ul>
        <p>
            Let's begin with some models
            @Html.DisplayCode(@"
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace QueryIt
{
    public class Person
    {
        public string Name { get; set; }
    }

    public class Employee : Person
    {
        public int Id { get; set; }
        public virtual void DoWork()
        {
            Console.WriteLine(""Doing real Work"");
        }
    }

    public class Manager : Employee
    {
        public override void DoWork()
        {
            Console.WriteLine(""Create a meeting"");
        }
    }
}

", "c#")
        </p>
        <p>
            And now let's add Entity Framework connect our model. After having Entity Framework, Let's have the below code:
            @Html.DisplayCode(@"
using System;
using System.Data.Entity;
using System.Linq;

namespace QueryIt
{
    public class EmployeeDb : DbContext
    {
        public DbSet<Employee> Employees { get; set; }
        public DbSet<Manager> Managers { get; set; }
    }

    public interface IRepository<T> : IDisposable
    {
        void Add(T newEntity);
        void Delete(T entity);
        T FindById(int id);
        IQueryable<T> FindAll();
        int Commit();
    }

    public class SqlRepository<T> : IRepository<T>
    {
        private DbContext _ctx;
        private DbSet<T> _set;

        public SqlRepository(DbContext ctx)
        {
            _ctx = ctx;
            _set = _ctx.Set<T>();
        }

        public void Add(T newEntity)
        {
            _set.Add(newEntity);
        }

        public void Delete(T entity)
        {
            throw new NotImplementedException();
        }

        public T FindById(int id)
        {
            throw new NotImplementedException();
        }

        public IQueryable<T> FindAll()
        {
            throw new NotImplementedException();
        }

        public int Commit()
        {
            return _ctx.SaveChanges();
        }

        public void Dispose()
        {
            _ctx.Dispose();
        }
    }

}

", "c#")
        </p>
        <p>
            And notice that the compiler is not happy when we build this code. It Says:
        </p>
        <p>
            <img src="../../Content/Images/Generics/9.png" alt="" />
        </p>
        <p>
            Before we fix this, let's jump in the <code>DbSet</code> definition once:
        </p>
        <p>
            <img src="../../Content/Images/Generics/10.png" alt="" />
        </p>
        <p>
            <code>@Html.Raw(Html.Encode("SqlRepository<T>"))</code> is confident that i can accept any type as my type argument. But if it does accepts a primitive type, the <code>DbSet</code> will be unhappy because it can only accept a reference type. So Let's fix the code:
            @Html.DisplayCode(@"
public class SqlRepository<T> : IRepository<T> where T : class
    {
        private DbContext _ctx;
        private DbSet<T> _set;

        public SqlRepository(DbContext ctx)
        {
            _ctx = ctx;
            _set = _ctx.Set<T>();
        }

        public void Add(T newEntity)
        {
            _set.Add(newEntity);
        }

        public void Delete(T entity)
        {
            throw new NotImplementedException();
        }

        public T FindById(int id)
        {
            throw new NotImplementedException();
        }

        public IQueryable<T> FindAll()
        {
            throw new NotImplementedException();
        }

        public int Commit()
        {
            return _ctx.SaveChanges();
        }

        public void Dispose()
        {
            _ctx.Dispose();
        }
    }
", "c#")
        </p>
        <p>
            @Html.DisplayCode(@"
using System;
using System.Data.Entity;
using System.Linq;

namespace QueryIt
{
    class Program
    {
        static void Main(string[] args)
        {

            Database.SetInitializer(new DropCreateDatabaseAlways<EmployeeDb>());

            using (IRepository<Employee> employeeRepository = new SqlRepository<Employee>(new EmployeeDb()))
            {
                AddEmployees(employeeRepository);
                CountEmployees(employeeRepository);
            }


        }

        private static void CountEmployees(IRepository<Employee> employeeRepository)
        {
            Console.WriteLine(employeeRepository.FindAll().Count());
        }

        private static void AddEmployees(IRepository<Employee> employeeRepository)
        {
            employeeRepository.Add(new Employee { Name = ""Scott"" });
            employeeRepository.Add(new Employee { Name = ""Chris"" });
            employeeRepository.Commit();
        }
    }
}

", "c#")
        </p>
        <p>
            <img src="../../Content/Images/Generics/11.png" alt="" />
        </p>
        <p>
            Let's talk a little about <em><strong>Interface Constraint</strong></em>. Let's say our little <code>Add</code> method wants to have a validation before it adds something to the database. Like so:
            @Html.DisplayCode(@"
public void Add(T newEntity)
        {
            if (newEntity.IsValid())
            {

            }
            _set.Add(newEntity);
        }
", "c#")
        </p>
        <p>
            But this throws a compiler error that the type <code>T</code> does not implements <code>IsValid</code>. This is because every Type Parameter unless constrained derives from <code>System.Object</code> and currently only has methods that <code>System.Object</code> implements like <code>ToString()</code>, <code>GetHashCode()</code> etc.
        </p>
        <p>
            In order to make something available to <code>T</code> lets have another Interface constraint like so:
            @Html.DisplayCode(@"
public interface IEntity
    {
        bool IsValid();
    }

    public class Person
    {
        public string Name { get; set; }
    }

    public class Employee : Person //,IEntity
    {
        public int Id { get; set; }
        public virtual void DoWork()
        {
            Console.WriteLine(""Doing real Work"");
        }
    }
", "c#")
            @Html.DisplayCode(@"
public class SqlRepository<T> : IRepository<T> where T : class, IEntity
    {
        private DbContext _ctx;
        private DbSet<T> _set;

        public SqlRepository(DbContext ctx)
        {
            _ctx = ctx;
            _set = _ctx.Set<T>();
        }

        public void Add(T newEntity)
        {
            if (newEntity.IsValid())
            {

            }
            _set.Add(newEntity);
        }

        public void Delete(T entity)
        {
            throw new NotImplementedException();
        }

        public T FindById(int id)
        {
            throw new NotImplementedException();
        }

        public IQueryable<T> FindAll()
        {
            return _set;
        }

        public int Commit()
        {
            return _ctx.SaveChanges();
        }

        public void Dispose()
        {
            _ctx.Dispose();
        }
    }
", "c#")
        </p>

        <p>
            The compiler is happy the way we implemented our <code>SqlRepository</code>. It only throws a compiler error now where we instantiate a <code>SqlRepository</code>. The Type Argument for <code>SqlRepository</code> must implement <code>IEntity</code>.

        </p>
        <p>
            <img src="../../Content/Images/Generics/12.png" alt="" />
        </p>
        <p>
            So let's fix the <code>Employee</code> class now.
            @Html.DisplayCode(@"
public class Employee : Person ,IEntity
    {
        public int Id { get; set; }
        public virtual void DoWork()
        {
            Console.WriteLine(""Doing real Work"");
        }

        public bool IsValid()
        {
            return true;
        }
    }
", "c#")
        </p>
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">More about constraints</div>
    </div>
    <div class="panel-body">
        <ul>
            <li>Either <code>class</code> or <code>struct</code> can be applied. And it should be written before any Interface constraint.</li>
            <li>Either a concrete Type or class/struct can appear as a constraint. not both.</li>
            <li>
                A constraint can come from a Type Parameter like so:
                @Html.DisplayCode(@"
public class SqlRepository<T, T2> : IRepository<T> where T : T2, IEntity
", "c#")
                This does not makes much sense in this context, but this is available.
            </li>
            <li>
                In case you try to initialize <code>T</code> like so:
                @Html.DisplayCode(@"
public T FindById(int id)
{
    T entity = new T();

    return T;
}
", "c#")
                This will throw a compiler error because you are not sure if T could be instantiated by a <code>new</code> operator or not. So we apply another constraint here like so:
                @Html.DisplayCode(@"
public class SqlRepository<T> : IRepository<T> where T : class, IEntity, new()
", "c#")
                The <code>new()</code> constraint always comes at last. Now the compiler will always check if the type <code>T</code> has a default constructor.
            </li>
            <li>
                In case you have another generic Type parameter <code>T2</code> then you apply the constraint like so:
                @Html.DisplayCode(@"
public class SqlRepository<T, T2> : IRepository<T> where T : class, IEntity, new()
                                                   where T2 : class, IEntity //...
", "c#")
            </li>
            <li>
                Its perfectly leagal to have constraints applied to one of the interfaces directly, but try to avoid this.
            </li>
        </ul>
        <p>
            Here is the final code till now:
            @Html.DisplayCode(@"
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace QueryIt
{

    public interface IEntity
    {
        bool IsValid();
    }

    public class Person
    {
        public string Name { get; set; }
    }

    public class Employee : Person ,IEntity
    {
        public int Id { get; set; }
        public virtual void DoWork()
        {
            Console.WriteLine(""Doing real Work"");
        }

        public bool IsValid()
        {
            return true;
        }
    }

    public class Manager : Employee
    {
        public override void DoWork()
        {
            Console.WriteLine(""Create a meeting"");
        }
    }
}

", "c#")
            @Html.DisplayCode(@"
using System;
using System.Data.Entity;
using System.Linq;

namespace QueryIt
{
    public class EmployeeDb : DbContext
    {
        public DbSet<Employee> Employees { get; set; }
        public DbSet<Manager> Managers { get; set; }
    }

    public interface IRepository<T> : IDisposable
    {
        void Add(T newEntity);
        void Delete(T entity);
        T FindById(int id);
        IQueryable<T> FindAll();
        int Commit();
    }

    public class SqlRepository<T> : IRepository<T> where T : class, IEntity
    {
        private DbContext _ctx;
        private DbSet<T> _set;

        public SqlRepository(DbContext ctx)
        {
            _ctx = ctx;
            _set = _ctx.Set<T>();
        }

        public void Add(T newEntity)
        {
            if (newEntity.IsValid())
            {

            }
            _set.Add(newEntity);
        }

        public void Delete(T entity)
        {
            _set.Remove(entity);
        }

        public T FindById(int id)
        {
            return _set.Find(id);
        }

        public IQueryable<T> FindAll()
        {
            return _set;
        }

        public int Commit()
        {
            return _ctx.SaveChanges();
        }

        public void Dispose()
        {
            _ctx.Dispose();
        }
    }

}

", "c#")
            @Html.DisplayCode(@"
using System;
using System.Data.Entity;
using System.Linq;

namespace QueryIt
{
    class Program
    {
        static void Main(string[] args)
        {

            Database.SetInitializer(new DropCreateDatabaseAlways<EmployeeDb>());

            using (IRepository<Employee> employeeRepository = new SqlRepository<Employee>(new EmployeeDb()))
            {
                AddEmployees(employeeRepository);
                CountEmployees(employeeRepository);
                QueryEmployees(employeeRepository);
            }

            Console.ReadLine();
        }

        private static void QueryEmployees(IRepository<Employee> employeeRepository)
        {
            var employee = employeeRepository.FindById(1);
            Console.WriteLine(employee.Name);
        }

        private static void CountEmployees(IRepository<Employee> employeeRepository)
        {
            Console.WriteLine(employeeRepository.FindAll().Count());
        }

        private static void AddEmployees(IRepository<Employee> employeeRepository)
        {
            employeeRepository.Add(new Employee { Name = ""Scott"" });
            employeeRepository.Add(new Employee { Name = ""Chris"" });
            employeeRepository.Commit();
        }
    }
}

", "c#")
        </p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Covariance</div>
    </div>
    <div class="panel-body">
        Let's add another method in our <code>Program.cs</code>
        @Html.DisplayCode(@"
private static void DumpPeople(IRepository<Employee> employeeRepository)
{
    var employees = employeeRepository.FindAll();
    foreach (var employee in employees)
    {
        Console.WriteLine(employee.Name);
    }
}
", "c#")
        <p>
            In case we just want to dump the names, it should be in the spirit of good object oriented programming to convert this method to accept <code>@Html.Raw(Html.Encode("IRepository<Person>"))</code>. And since <code>Employee</code> is a <code>Person</code> this piece of logic makes sense:
            @Html.DisplayCode(@"
private static void DumpPeople(IRepository<Person> employeeRepository)
{
    var employees = employeeRepository.FindAll();
    foreach (var employee in employees)
    {
        Console.WriteLine(employee.Name);
    }
}
", "c#")
        <p>
            And use it as such:
            @Html.DisplayCode(@"
using (IRepository<Employee> employeeRepository = new SqlRepository<Employee>(new EmployeeDb()))
{
    AddEmployees(employeeRepository);
    CountEmployees(employeeRepository);
    QueryEmployees(employeeRepository);
    DumpPeople(employeeRepository);
}
", "c#")
        </p>
        <p>
            But, this throws a compiler error: And it seems odd from the perspective of Object Oriented Programming.
        </p>
        <p>
            <img src="../../Content/Images/Generics/13.png" alt="" />
        </p>
        <p>
            Notice this is not the case with <code>@Html.Raw(Html.Encode("IEnumerable<T>"))</code>.
            @Html.DisplayCode(@"
IEnumerable<Employee> temp = employeeRepository.FindAll();
IEnumerable<Person> temp = employeeRepository.FindAll();
", "c#")
        </p>
        <p>The above code does not throws any compiler error. <code>@Html.Raw(Html.Encode("IQueryable<T>"))</code> implements <code>@Html.Raw(Html.Encode("IEnumerable<T>"))</code>. In the above code <code>@Html.Raw(Html.Encode("IQueryable<Employee>"))</code> can be assigned to both <code>@Html.Raw(Html.Encode("IEnumerable<Employee>"))</code> and <code>@Html.Raw(Html.Encode("IEnumerable<Person>"))</code>  If the above works fine, what is wrong with <code>@Html.Raw(Html.Encode("IRepository<T>"))</code></p>
        <p>
            Well if we see the definition of <code>@Html.Raw(Html.Encode("IEnumerable<T>"))</code> in the metadata:
            @Html.DisplayCode(@"
using System.Collections;
using System.Runtime.CompilerServices;

namespace System.Collections.Generic
{
    public interface IEnumerable<out T> : IEnumerable
    {
        IEnumerator<T> GetEnumerator();
    }
}

", "c#")
        </p>
        <p>
            Notice the <code>out</code> keyword with the Type parameter. <code>out</code> is a <em><strong>Generic Modifier</strong></em>. And it means that <code>@Html.Raw(Html.Encode("IEnumerable<T>"))</code> is <em><strong>Covariant</strong></em>. This is in contrast to when the Generic Modifier is not present. That will be <em><strong>Invariant</strong></em>. As the name implies there is no <em><strong>variance</strong></em>.
        </p>
        <p>
            The methods inside a covariant interface are allowed to return a type that is more derived than the type specified by the generic type parameter. Notice, more derived. In other words, a covariant interface like <code>@Html.Raw(Html.Encode("IEnumerable"))</code> would allow <code>GetEnumerator</code> to return <code>@Html.Raw(Html.Encode("IEnumerable<Employee>"))</code> even when the <code>T</code> is type <code>Person</code>. <code>Employee</code> is more derived than <code>Person</code>.
        </p>
        <p>
            And that makes a lot of sense from an object-oriented point of view. If something is always giving me back <code>Employee</code> objects, why can't i just treat those objects as <code>Person</code> objects since every employee is a person. It's just that in c# that does require the <code>out</code> modifier to explicitly make the interface covariant, and covariance only works with <code>delegate</code>s and <code>interface</code>s.
        </p>
        <p>
            Let's go back to our code and make <code>@Html.Raw(Html.Encode("IRepository<T>"))</code> covariant.
            @Html.DisplayCode(@"
public interface IRepository<out T> : IDisposable
{
    void Add(T newEntity);
    void Delete(T entity);
    T FindById(int id);
    IQueryable<T> FindAll();
    int Commit();
}
", "c#")
        </p>
        <p>
            But now the compiler gives me some other errors:
        </p>
        <p>
            <img src="../../Content/Images/Generics/14.png" alt="" />
        </p>
        <p>
            The reason for these errors is that covariance is only supported when you have methods returning the covariant type parameter. It's dangerous and illeagal as far as the c# compiler is concerned to make an interface covariant when methods take parameters of type <code>T</code>. And if you think very deeply about this, it makes sense.
        </p>
        <p>
            Imagine i have an <code>@Html.Raw(Html.Encode("IRepository<Employee>"))</code> and i pass it to someone who treats it as an <code>@Html.Raw(Html.Encode("IRepository<Person>"))</code>. It would be ok to read objects from that repository because all the objects it returns are Employees which derive from Person, so that's never going to cause a problem, but it would be bad to give that repository a Person as a parameter because the repository might try to interact with it or save it or use some characteristic of an Employee when the object it got was really only a Person.(<code>Person</code> object might not contain all the properties of <code>Employee</code> object.) So, can i make <code>@Html.Raw(Html.Encode("IRepository<T>"))</code> covariant?
        </p>
        <p>
            The answer would be no. But there are work arounds. Divide <code>@Html.Raw(Html.Encode("IRepository<T>"))</code> to separate interfaces, one that contains read operations and the other that contains write operations.
            @Html.DisplayCode(@"
 public interface IReadOnlyRepository<out T> : IDisposable
{
    T FindById(int id);
    IQueryable<T> FindAll();
}

public interface IRepository<T> : IReadOnlyRepository<T> ,IDisposable
{
    void Add(T newEntity);
    void Delete(T entity);
    int Commit();
}
", "c#")
        </p>
        <p>
            And also change the signature for <code>DumpPeople</code> like so:
            @Html.DisplayCode(@"
private static void DumpPeople(IReadOnlyRepository<Person> employeeRepository)
{
    var employees = employeeRepository.FindAll();
    foreach (var employee in employees)
    {
        Console.WriteLine(employee.Name);
    }
}
", "c#")
        </p>
        <p>
            So this is a scenario of why covariance is requried. This can be generalized to <em>I want to use some logic and work with base types as much as possible and covariance helps to enable that because i can treat <code>@Html.Raw(Html.Encode("IEnumerable<T>"))</code> or <code>@Html.Raw(Html.Encode("IReadOnlyRepository<Employee>"))</code> as an <code>@Html.Raw(Html.Encode("IEnumerable"))</code> or <code>@Html.Raw(Html.Encode("IReadOnlyRepository<Person>"))</code> and that allows me to share the logic in between <code>Employee</code> and <code>Person</code></em>
        </p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Contravariance</div>
    </div>
    <div class="panel-body">
        <em><strong>Contravariance</strong></em> is opposite of <em><strong>Covariance</strong></em>. Let's see a code where i want to add managers using an Employee Repository:
        @Html.DisplayCode(@"
private static void AddManagers(IRepository<Employee> employeeRepository)
        {
            employeeRepository.Add(new Manager { Name = ""Alex"" });
            employeeRepository.Commit();
        }
", "c#")
        <p>
            This looks fine, but what if i want to convert my method to accept an <code>@Html.Raw(Html.Encode("IRepository<Manager>"))</code> using an Employee Repository.
            @Html.DisplayCode(@"
private static void AddManagers(IRepository<Manager> employeeRepository)
        {
            employeeRepository.Add(new Manager { Name = ""Alex"" });
            employeeRepository.Commit();
        }
", "c#") This throws a compiler error because <code>@Html.Raw(Html.Encode("IRepository<T>"))</code> is invariant.
</p>
<p>
    <img src="../../Content/Images/Generics/15.png" alt="" />
</p>
<p>
    This is where contravariance comes into picture. It uses the <code>in</code> generic modifier.
    @Html.DisplayCode(@"
 public interface IRepository<in T> : IReadOnlyRepository<T> ,IDisposable
{
    void Add(T newEntity);
    void Delete(T entity);
    int Commit();
}
", "c#") But there is still a compiler error :
</p>
<p>
    <img src="../../Content/Images/Generics/16.png" alt="" />
</p>
<p>
    To fix this let's create another interface which is contravariant:
    @Html.DisplayCode(@"
public interface IWriteOnlyRepository<in T> : IDisposable
{
    void Add(T newEntity);
    void Delete(T entity);
    int Commit();
}

public interface IReadOnlyRepository<out T> : IDisposable
{
    T FindById(int id);
    IQueryable<T> FindAll();
}

public interface IRepository<T> : IReadOnlyRepository<T> , IWriteOnlyRepository<T>
{

}
", "c#")
</p>
<p>
    And also fix the <code>AddManager</code> method:
    @Html.DisplayCode(@"
private static void AddManagers(IWriteOnlyRepository<Manager> employeeRepository)
        {
            employeeRepository.Add(new Manager { Name = ""Alex"" });
            employeeRepository.Commit();
        }
", "c#")
</p>
<p>
    <img src="../../Content/Images/Generics/17.png" alt="" />
</p>
<p>
    <img src="../../Content/Images/Generics/18.png" alt="" />
</p>
<p>
    Covariance : <code>Employee</code> casted to <code>Person</code>. This is possible because <code>Employee</code> will contain everything that a <code>Person</code> needs. Then you can read from this <code>Person</code>.
</p>
<p>
    Contravariance : <code>Employee</code> will accept a <code>Manager</code> when writing to <code>Employee</code> because <code>Manager</code> contains everything that <code>Employee</code> needs.
</p>
</div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Another Example of Covariance, Contravariance</div>
    </div>
    <div class="panel-body">
        <p>
            Initial Code
            @Html.DisplayCode(@"
void Main()
{
	IRepository<Animal> animalRepository = new Repository<Animal>();
	animalRepository.Add(new Animal{AnimalType=""Four Legged""});

	IRepository<Animal> anotherAnimalRepository = animalRepository;

	IEnumerable<Animal> animals = anotherAnimalRepository.FindAll();

	foreach (var animal in animals)
	{
		Console.WriteLine (animal.AnimalType);
	}
}



public interface IRepository<T>
{
	void Add(T creature);
	IQueryable<T> FindAll();
}

public class Repository<T> : IRepository<T>
{
	private List<T> _beings;

	public Repository()
	{
		_beings = new List<T>();
	}

	public void Add(T being)
	{
		_beings.Add(being);
	}

	public IQueryable<T> FindAll()
	{
		return _beings.AsQueryable();
	}
}


public class Creature
{
	public String Type { get; set; }
}

public class Animal : Creature
{
	public String AnimalType {get; set;}
}

public class Dog : Animal
{
	public String Name {get; set;}
}
", "c#")
        </p>
        <p>
            Covariance Code
            @Html.DisplayCode(@"
void Main()
{
	IRepository<Animal> animalRepository = new Repository<Animal>();
	animalRepository.Add(new Animal{AnimalType=""Four Legged"", Type = ""Animal""});

	//IRepository<Animal> anotherAnimalRepository = animalRepository;

	IReadOnlyRepository<Creature> creatureRepository = animalRepository;

	IEnumerable<Creature> creatures = creatureRepository.FindAll();

	foreach (var creature in creatures)
	{
		Console.WriteLine (creature.Type);
	}
}

public interface IReadOnlyRepository<out T>
{
	IQueryable<T> FindAll();
}


public interface IRepository<T> : IReadOnlyRepository<T>
{
	void Add(T creature);

}

public class Repository<T> : IRepository<T>
{
	private List<T> _beings;

	public Repository()
	{
		_beings = new List<T>();
	}

	public void Add(T being)
	{
		_beings.Add(being);
	}

	public IQueryable<T> FindAll()
	{
		return _beings.AsQueryable();
	}
}


public class Creature
{
	public String Type { get; set; }
}

public class Animal : Creature
{
	public String AnimalType {get; set;}
}

public class Dog : Animal
{
	public String Name {get; set;}
}
", "c#")
        </p>
        <p>
            Contravariance Code
            @Html.DisplayCode(@"
void Main()
{
	IRepository<Animal> animalRepository = new Repository<Animal>();
	animalRepository.Add(new Animal{AnimalType=""Four Legged"", Type = ""Animal""});

	IWriteOnlyRepository<Dog> dogRepository = animalRepository;
	dogRepository.Add(new Dog{Name = ""Bruno""});


	IEnumerable<Creature> creatures = animalRepository.FindAll();

	foreach (var creature in creatures)
	{
		Console.WriteLine (creature.Type);
	}

}


public interface IWriteOnlyRepository<in T>
{
	void Add(T creature);
}

public interface IReadOnlyRepository<out T>
{
	IQueryable<T> FindAll();
}


public interface IRepository<T> : IReadOnlyRepository<T>, IWriteOnlyRepository<T>
{


}

public class Repository<T> : IRepository<T>
{
	private List<T> _beings;

	public Repository()
	{
		_beings = new List<T>();
	}

	public void Add(T being)
	{
		_beings.Add(being);
	}

	public IQueryable<T> FindAll()
	{
		return _beings.AsQueryable();
	}
}


public class Creature
{
	public String Type { get; set; }
}

public class Animal : Creature
{
	public String AnimalType {get; set;}
}

public class Dog : Animal
{
	public String Name {get; set;}
}
", "c#")
        </p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">More with Generics</div>
    </div>
    <div class="panel-body">
        <p>
            Enums:
        </p>
        <p><img src="../../Content/Images/Generics/19.png" alt="" /></p>
        <p>But this throws a compiler error, <em><strong><code>System.Enum</code>s are not allowed as a constraint</strong></em></p>
        <p>
            Math Problem
        </p>
        <p>
            <img src="../../Content/Images/Generics/20.png" alt="" />
        </p>
        <p>In case for the above code you need to need to implement it for <code>double</code> too, you might think this is something for which i can create a generic method. But there is no contstraint that says that the coming Type parameter must be able to do <code>+=</code> or <code>/</code> operations. So for this case Generic method is not possible for now.</p>
        <p>
            Generic Type inherits from Non Generic Type base class
        </p>
        <p>
            <img src="../../Content/Images/Generics/21.png" alt="" />
        </p>
        <p>
            Static field/property is no longer shared across for different type argument.
        </p>
        <p>
            <img src="../../Content/Images/Generics/22.png" alt="" />
        </p>
        <p>
            You need to pass the type parameter to get the number of instance with that type parameter. This prooves that a generic type with a specific type parameter is a different type as compared to that generic type with some other type parameter.
        </p>
        <p>
            BUT, if you have the static field/property in a non generic base class, that is shared across different generic types with different type parameter.
        </p>
        <p>
<img src="../../Content/Images/Generics/23.png" alt="" />
        </p>
        <p>
<img src="../../Content/Images/Generics/3.png" alt="" />
        </p>
    </div>
</div>