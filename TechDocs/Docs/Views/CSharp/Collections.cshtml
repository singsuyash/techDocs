@{
    ViewBag.Title = "Collections";
}

<h2>Collections</h2>

<p>
    We will talk about different types of collections, several collection interfaces and how they work under the hood.
</p>
<p>
    The course will be as follows:
    <ul>
        <li>Introduction</li>
        <li>
            Arrays
            <ul>
                <li>Inside Arrays</li>
                <li>Array capabilities</li>
            </ul>
        </li>
        <li>Interfaces</li>
        <li>
            Collection Types
            <ul>
                <li>Index-based lists</li>
                <li>Other lists(Linked Lists, Stacks, Queues)</li>
                <li>Dictionaries</li>
                <li>Sets</li>
            </ul>
        </li>
        <li>Enumerators</li>
        <li>Multidimensional and Jagged Arrays</li>
    </ul>
</p>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Collection Introduction</div>
    </div>
    <div class="panel-body">
        <ul>
            <li>
                What is a collection
                <ul>
                    <li>Collection Operations</li>
                </ul>
            </li>
            <li>
                Types of collection
                <ul>
                    <li>Lists</li>
                    <li>Dictionaries</li>
                    <li>Sets</li>
                </ul>
            </li>
            <li>
                Collections in .NET
                <ul>
                    <li>A brief history</li>
                    <li>The current collection landscape</li>
                </ul>
            </li>
        </ul>
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">What is a collection</div>
    </div>
    <div class="panel-body">
        <p>A collection is a <em>Type</em> responsible to manage groups of other objects in memory</p>
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Types of collection</div>
    </div>
    <div class="panel-body">
        <p>All the collections provided by .net come under Lists, Dictionaries or Sets</p>
        <p>
            In some collections sometimes the order of elements is important, this is <em>List</em>. These have indexes. Good for memory use, efficient for accessing elements. List Types in .NET
            <ul>
                <li><code>@Html.Raw(Html.Encode("T[]"))</code> - Array</li>
                <li><code>@Html.Raw(Html.Encode("List<T>"))</code></li>
                <li><code>@Html.Raw(Html.Encode("Collection<T>"))</code></li>
                <li><code>@Html.Raw(Html.Encode("ReadOnlyCollection<T>"))</code></li>
                <li><code>@Html.Raw(Html.Encode("ObservableCollection<T>"))</code></li>
                <li><code>@Html.Raw(Html.Encode("IList<T>"))</code> - This is a definitive contract for all lists</li>
            </ul>
        </p>
        <br />
        <p>
            When the order is not important, for example <em>staff of an organization</em>. They need not have an order, this is <em>Dictionary</em>. Accessing items by index is not required. Access is based on a Key.
            <ul>
                <li><code>@Html.Raw(Html.Encode("Dictionary<TKey, TValue>"))</code></li>
                <li><code>@Html.Raw(Html.Encode("IDictionary<TKey, TValue>"))</code> -  This is a definitive contract for all dictionaries</li>
            </ul>
        </p>
        Most of the dictionaries are implemented using a <em>hash table</em>.
        <p>
            For example:
            Declare a dictionary that allows looking up by a name:
            @Html.DisplayCode(@"
var employees = new Dictionary<string, Employee>();
", "C#")
            Or, for looking up by social security no. declare:
            @Html.DisplayCode(@"
var employees = new Dictionary<SocialSecNo, Employee>();
", "C#")
        </p>
        <p>
            Lists are faster to access than dictionaries
            <img src="../../Content/Images/ListVsDictionaryAccessSpeed.png" alt="" />
        </p>

        <br />
        <p>
            The focus is not on accessig a single element, but treating the whole group as one. This is <em>Sets</em>. This is same as the sets in set theory. To find out intersection, union etc. Sets are collections that support being combined to form new sets
            <ul>
                <li><code>@Html.Raw(Html.Encode("HashSet<T>"))</code></li>
                <li><code>@Html.Raw(Html.Encode("ISet<T>"))</code> - Contract for sets</li>
            </ul>
            Similarity between <em>dictionary</em> and <em>Set</em> is that both are often based on hashtable. Difference is that a dictionary lookup with keys. In sets there is <em>no lookup</em>.
        </p>
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Collection Operations</div>
    </div>
    <div class="panel-body">
        <ul>
            <li>
                Reading
                <ul>
                    <li>Single item Through index or keys</li>
                    <li>
                        All items through enumerator using a foreach loop
                        <ul>
                            <li>elements in a list are enumerated in the index order</li>
                            <li>elements in the dictionary are not enumerated in the order, so dont rely for a order in a dictionary.</li>
                        </ul>
                    </li>
                    <li>Sets don't support lookin up of an item, there are a few list types too that dont support a lookup(Linked lists, Stacks, Queues)</li>
                </ul>
            </li>
            <li>
                Writing
                <ul>
                    <li>
                        Add an item
                        <ul>
                            <li>In lists you might want to add an item at a particular order</li>
                            <li>In dictionaries it does not matter</li>
                        </ul>
                    </li>
                    <li>Remove an item</li>
                    <li>Replace an item</li>
                </ul>
            </li>
            <li>
                Derived operation
                <ul>
                    <li>Filter a list - this is reading all the items and fetching which satisfies the condition</li>
                </ul>
                Usually this is done using <em>LINQ</em>
            </li>
        </ul>
        <img src="../../Content/Images/collectionOperations.png" alt="" />
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Collections in .NET</div>
    </div>
    <div class="panel-body">
        <img src="../../Content/Images/CollectionHistory.png" alt="" />
        <ul>
            <li>
                Generics in .NET 2.0
                <p><code>@Html.Raw(Html.Encode("List<T>"))</code> was introduced. instead of list of a type earlier there was only <em>ArrayList(of object)</em> available that would be a list of your type, but you have to box and unbox that object to the type and vice versa to use it.</p>
                <p>But there was an Array that could hold a collection of types. But due to differences between Arrays and Generics, Generics prevailed.</p>
                <p>
                    What came along was :
                    <ul>
                        <li><code>@Html.Raw(Html.Encode("HashSet<T>, Stack<T>, Queue<T>, LinkedList<T>, List<T>, Dictionary<TKey, TValue>"))</code></li>
                    </ul>
                </p>
            </li>
            <li>
                LINQ in .NET 3.0
                <p>Adds operations to anything enumerable - including collections</p>
            </li>
            <li>
                Concurrent Collections .NET 4.0
                <p>Multi-threaded support (Not covered in this course)</p>
            </li>
            <li>
                Readonly Interfaces, Immutable collections
                <ul>
                    ReadOnly Interfaces
                    <li><code>@Html.Raw(Html.Encode("IReadOnlyList<T>"))</code></li>
                    <li><code>@Html.Raw(Html.Encode("IReadOnlyCollection<T>"))</code></li>
                </ul>
            </li>
        </ul>
        <img src="../../Content/Images/CollectionsToday.png" alt="" />
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Inside Arrays</div>
    </div>
    <div class="panel-body">
        <p>This section will deal with "What arrays are", "how do they work", "C# syntax to use them".</p>
        <p>Next module will cover the implementation of arrays in .NET, how arrays fit into the .NET type system and the rich functionality that the managed array type implements</p>
        <ul>
            <li>
                What is an array
                <ul>
                    <li>Basic Syntax</li>
                </ul>
            </li>
            <li>
                Arrays under the hood
                <ul>
                    <li>Element access is very efficient</li>
                </ul>
            </li>
            <li>Declaring and initializing arrays</li>
            <li>
                Enumerating(iterating) array contents
                <ul>
                    <li>foreach loop</li>
                    <li>for loop</li>
                </ul>
            </li>
        </ul>
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">What are Arrays</div>
    </div>
    <div class="panel-body">
        <ul>
            <li>Index based list</li>
            <li>rich api</li>
            <li>very lightweight</li>
            <li>special c# syntax</li>
            <li>fixed size - this is a drawback</li>
        </ul>
        An example for which arrays will suit best : Consider the days of a week where <em>Order</em> and <em>Size</em> are fixed.
        <p>
            <code>type[]</code> - declares array, not simple type
        </p>

        <p>
            Iterating with foreach
            @Html.DisplayCode(@"
foreach (var day in daysOfWeek)
			{
				Console.WriteLine(day);
			}
", "c#")
        </p>
        <p>Notice we can replace an array item as such : <code>daysOfWeek[4]="PartyDay"</code></p>.
        <p>Since arrays have a fixed size, we can not remove or add an item.</p>
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Arrays under the Hood</div>
    </div>
    <div class="panel-body">
        <ul>
            <li>Special syntax in c# i.e. <code>int[] iHaveSquareBrackets</code>. No other type will use square brackets</li>
            <li>
                <code>T[]</code> is a reference type
                @Html.DisplayCode(@"
void Main()
{
	int[] x = new int[5]{1234,23,356,7,6};
	change(x);
	Console.WriteLine (x[0]);
}

// Define other methods and classes here

public void change(int[] intArray)
{
	intArray[0] = 5;
}
", "c#")
                The output is 5;
            </li>
            <li>Implemented in the CLR itself</li>
            <li>
                Other Collections are implemented using generics. And internally they are mostly implemented using Arrays!
                <p>For example, the generic collection <code>@Html.Raw(Html.Encode("List<T>"))</code> is a wrapper around <code>T[]</code> and the wrapper adds additional features.</p>
            </li>
            <li>
                How arrays are stored
                <ul>
                    <li>
                        Consider an integer array
                        @Html.DisplayCode(@"
int[] squares = {1, 2, 9, 16, 25}
", "c#")
                        <p><code>int</code> occupies 4 bytes. This array is stored in a continous memory stream. Each array element is of 4 bytes.</p>
                        <p>Since all elements are of equal size, consider the memory address of the 0th element at <em><strong>X</strong></em>. 1st element will be at <em><strong>X+4Bytes</strong></em>. 2nd element will be at <em><strong>X+2*4Bytes</strong></em>. Nth element will be at <em><strong>X+(N-1)*4Bytes</strong></em></p>
                        <p>Now, when we lookup an array element this direct formula can be applied. This demonstrates the speed of accessing an array element.</p>
                        <p><code>int</code> have a fixed size of 4 Bytes, but what about a complex type whose size can vary. In this case the formula becomes <em><strong>X+(N-1)*YBytes</strong></em> where Y in case of <code>int</code> was 4 but for comples types it can not be determined always.</p>
                        <p>Are we forgetting something :). Complex types are reference types. Each reference points to a memory location which is <em><strong>Y Bytes</strong></em>. In case of <code>T[]</code> the continous memory stream is of references, not actual data and fortunately in 64 bit machine, this reference size is of 8 bytes. This makes the formula as <em><strong>X+(N-1)*8Bytes</strong></em>, and once again the jumping or array lookup becomes quick.</p>
                        <p>Note that these references are actually memory addresses. Addresses are always integers</p>
                    </li>
                    <li>
                        Let's try to understand why arrays are of fixed size:
                        <p><img src="../../Content/Images/arrayfixedsize.png" alt="" /></p>
                        Here we can see that if we want to add some more elements to an array, the memory stream after the last element of the array might not be free. If it is not free, the way of accessing an array i.e. <em><strong>X+(N-1)*YBytes</strong></em> will not hold.
                    </li>
                </ul>
            </li>

        </ul>
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">How Arrays are initialized</div>
    </div>
    <div class="panel-body">
        <ul>
            <li>
                Since arrays are refernce types, the below code is not initialized yet.
                @Html.DisplayCode(@"
int[] x;
Console.WriteLine(x[0].ToString());
", "C#")
                The above code will throw an error "use of unassigned variable". But if you just new it up and don't assign any value, just like a reference type, the variable will be filled with the default values.
                @Html.DisplayCode(@"
int[] x = new int[5];
Console.WriteLine(x[1].ToString());
", "c#")
                This will output <code>0</code> as default value for <code>int</code> in reference types is 0.
            </li>
            <li>
                <p>
                    Array Initializer
                    <ul>
                        <li>
                            @Html.DisplayCode(@"
string[] daysOfWeek = {
						""Monday"",
						""Tuesday"",
						""Wednesday"",
						""Thursday"",
						""Friday"",
						""Saturday"",
						""Sunday""
					};


", "c#")
                        </li>
                        <li>
                            @Html.DisplayCode(@"


string[] DaysOfWeek = new string[7]{
		""Monday"",
		""Tuesday"",
		""Wednesday"",
		""Thursday"",
		""Friday"",
		""Saturday"",
		""Sunday""
};
", "c#")
                        </li>
                        <li>
                            Without the size
                            @Html.DisplayCode(@"


string[] DaysOfWeek = new string[]{
		""Monday"",
		""Tuesday"",
		""Wednesday"",
		""Thursday"",
		""Friday"",
		""Saturday"",
		""Sunday""
};
", "c#")
                        </li>
                    </ul>
                    Any expression that will evaluate at run time can come in the initializer
                </p>
            </li>
            <li>Consider <code>[]</code> as the Array constructor</li>
            <li>
                There is no way to initialize the array in the Array constructor
            </li>
            <li>Only thing that can be given in the Array constructor is the size of an array</li>
            <li>
                <img src="../../Content/Images/ArrayInitializerCompiler.png" alt="" />
            </li>
        </ul>
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Enumerating an Array</div>
    </div>
    <div class="panel-body">
        Enumerating through <code>foreach</code> and <code>for</code>. Difference as a developer is that index is available in <code>for</code>. But internally c# compiler converts <code>foreach</code> to <code>for</code>.
        @Html.DisplayCode(@"
using System;

namespace BasicArrayOps
{
	class Program
	{
		static void Main(string[] args)
		{

			int[] x = { 1, 2, 3, 4, 5 };
			foreach (int item in x)
			{
				Console.WriteLine(item);
			}
			Console.WriteLine();

			for (int i = 0; i < x.Length; i++)
			{
				Console.WriteLine(x[i] );
			}
			Console.ReadLine();
		}
	}
}

", "c#")<img src="../../Content/Images/enumerationOutput.png" alt="" />
        <p>For Arrays the compiler internally converts <code>foreach</code> to <code>for</code> but for other collection types it treats it differently.</p>
        <p>
            Usually for other collections its much easier to use <code>foreach</code>, so why have <code>for</code> at all.
            <ul>
                <li>Access index</li>
                <li>Conditions based on index</li>
                <li>
                    <code>foreach </code>can not run for specific element because the index is not available.
                </li>
                <li>
                    <code>foreach </code>is a readonly. i.e. we can not change the value of an element inside a <code>foreach </code>. But in a <code>for</code>loop we can
                    @Html.DisplayCode(@"
using System;

namespace BasicArrayOps
{
	class Program
	{
		static void Main(string[] args)
		{

			int[] x = { 1, 2, 3, 4, 5 };
			for (int i = 0; i < x.Length; i++)
			{
				if (x[i]==3)
				{
					x[i] = 5000;
				}
				Console.WriteLine(x[i]);
			}
			Console.ReadLine();
		}
	}
}

", "c#")<img src="../../Content/Images/changingvalueinforloop.png" alt="" />
                    @Html.DisplayCode(@"
using System;

namespace BasicArrayOps
{
	class Program
	{
		static void Main(string[] args)
		{

			int[] x = { 1, 2, 3, 4, 5 };

			foreach (var item in x)
			{
				if (item==3)
				{
					item = 5000;
				}
				Console.WriteLine(item);
			}
			Console.ReadLine();
		}
	}
}

", "c#")<img src="../../Content/Images/changingvalueinforeachloop.png" alt="" />
                    This is because the iteration placeholder variable cannot be assigned to. It is a readonly.
                </li>
            </ul>
        </p>
        <p>
            The reason why the iteration placeholder variable cannot be assigned to can be explained by the below code. Remember we said that internally <code>foreach</code> is replaced by a <code>for</code> for arrays.
            @Html.DisplayCode(@"
using System;

namespace BasicArrayOps
{
	class Program
	{
		static void Main(string[] args)
		{

			int[] x = { 1, 2, 3, 4, 5 };

			foreach (var item in x)
			{
				if (item==3)
				{
					item = 5000;
				}
				Console.WriteLine(item);
			}
			Console.ReadLine();
		}
	}
}

", "c#")
            The similar <code>for</code> equivalent can be
            @Html.DisplayCode(@"
using System;

namespace BasicArrayOps
{
	class Program
	{
		static void Main(string[] args)
		{

			int[] x = { 1, 2, 3, 4, 5 };
			for (int i = 0; i < x.Length; i++)
			{
				int item = x[i];
				if (item == 3)
				{
					item = 5000;
				}
				Console.WriteLine(x[i]);
			}

			Console.ReadLine();
		}
	}
}


", "c#")<img src="../../Content/Images/foreachtofor.png" alt="" />
            <div class="h3">This shows that element can not be replaced by another value. In case of immutable type's arrays the value is copied and can not be changed. In case of mutable reference type's arrays the reference is copied and can not be changed. BUT the reference can be <em><strong>modified</strong></em>.</div>
            @Html.DisplayCode(@"
using System;

namespace BasicArrayOps
{
	class Program
	{
		static void Main(string[] args)
		{

			Employee[] employees = new Employee[]{
				new Employee(){EmpId=1, Name=""susingh""},
				new Employee(){EmpId=2, Name=""scott""}
			};

			foreach (var employee in employees)
			{
				employee.Name = ""Ben"";
				Console.WriteLine(employee.Name);
			}

			Console.ReadLine();
		}
	}

	public class Employee
	{
		public int EmpId { get; set; }
		public string Name { get; set; }
	}
}

", "c#")<img src="../../Content/Images/changingmutablepropertyforeach.png" alt="" />
            But the below will throw an error
            @Html.DisplayCode(@"
using System;

namespace BasicArrayOps
{
	class Program
	{
		static void Main(string[] args)
		{

			Employee[] employees = new Employee[]{
				new Employee(){EmpId=1, Name=""susingh""},
				new Employee(){EmpId=2, Name=""scott""}
			};

			foreach (var employee in employees)
			{
				employee = new Employee() { EmpId = 5, Name = ""Ben"" };
				//employee.Name = ""Ben"";
				Console.WriteLine(employee.Name);
			}

			Console.ReadLine();
		}
	}

	public class Employee
	{
		public int EmpId { get; set; }
		public string Name { get; set; }
	}
}

", "c#")<img src="../../Content/Images/changingvalueinforeachloop.png" alt="" />
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Module Overview</div>
    </div>
    <div class="panel-body">
        <ul>
            <li>
                Arrays and the type system
                <ul>
                    <li>Reference Type</li>
                </ul>
            </li>
            <li>
                Storing derived Type Instances
                <ul>
                    <li>Covariance</li>
                </ul>
            </li>
            <li>
                Array capabilities
                <ul>
                    <li>Copying Arrays</li>
                    <li>Sorting elements</li>
                    <li>Finding elements</li>
                </ul>
            </li>
        </ul>
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Arrays as Reference Types</div>
    </div>
    <div class="panel-body">
        Proof that Arrays are reference types
        @Html.DisplayCode(@"
using System;

namespace BasicArrayOps
{
	class Program
	{
		static void Main(string[] args)
		{
			int[] x = { 1, 4, 9, 16 };
			var y = x;
			Console.WriteLine(""Reference Equals(x,y): "" + ReferenceEquals(x,y));

			Console.ReadLine();
		}
	}

}

", "C#")<img src="../../Content/Images/ArrayAsReference/ProofArrayAsRefernce.png" alt="" />
        Since Arrays are Reference types, <code>==</code> is same as <code>ReferenceEquals</code>.
        <p>All Collections are Refernces.</p>
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Storing Derived Instances in Arrays</div>
    </div>
    <div class="panel-body">
        In case we create an array of a Type <code>Base</code>, any derived type can be stored in this array.
        @Html.DisplayCode(@"
using System;

namespace BasicArrayOps
{
	class Program
	{
		static void Main(string[] args)
		{
			Animal[] animals = new Animal[] {
				new Animal(){TailLength=""10""},
				new Dog(){Name = ""Bruno"", TailLength=""8""},
				new Doberman(){Name=""Jimmy"", TailLength=""2""}
			};

			foreach (Animal animal in animals)
			{
				Console.WriteLine(""AnimalType: ""+animal.GetType().FullName+"", TailLength: ""+animal.TailLength);
			}

			Console.ReadLine();
		}
	}

	public class Animal
	{
		public string TailLength { get; set; }
	}

	public class Dog : Animal
	{
		public string Name { get; set; }
	}

	public class Doberman : Dog
	{

	}
}

", "c#")<img src="../../Content/Images/ArrayAsReference/TypeArrayCanContainDerivedType.png" alt="" />
        <p>This applies to all Collections and not just Arrays</p>
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">What is the Type of an Array</div>
    </div>
    <div class="panel-body">
        Any new Array type <code>T[]</code> is derived from <code>System.Array</code> which is derived from <code>System.Object</code>
        <p>Any new Array type is dynamically created at runtime</p>
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Array Covariance</div>
    </div>
    <div class="panel-body">
        You might assume that an array of <code>Derived</code> might be directly related to an array of <code>Base</code>. But this is not the case. Both <code>Derived</code> &amp; <code>Base</code> derive from <code>System.Array</code> which in turn derive from <code>System.Object</code>
        <p><img src="../../Content/Images/ArrayAsReference/ArraysDontInherit.png" alt="" /></p>
        <p>
            We know Type of a Derived array does not have a inheritance relationship with Type of a Base Array. But look at the below code
            @Html.DisplayCode(@"
using System;

namespace BasicArrayOps
{
	class Program
	{
		static void Main(string[] args)
		{
			string[] daysOfWeek = {
									  ""Monday"",
									  ""Tuesday"",
									  ""Wednesday"",
									  ""Thursday"",
									  ""Friday"",
									  ""Saturday"",
									  ""Sunday""
								  };
			object[] objArr = daysOfWeek;

			foreach (var item in objArr)
			{
				Console.WriteLine(item);
			}


			Console.ReadLine();
		}
	}

}

", "")<img src="../../Content/Images/ArrayAsReference/AssigningDerivedTypeArrayToBaseTypeArrayWorks.png" alt="" />
        </p>
        <p>
            This works! even though we are assigning a completely different type to another type. This is called <em><strong>Implicit casting</strong></em>. <code>Derived[]</code> can be implicitly casted to <code>Base[]</code>. This feature of Arrays is called <em><strong>Array Covariance</strong></em>
        </p>
        <p>
            Notice that this doesn't works for an array of value types.
            @Html.DisplayCode(@"
using System;

namespace BasicArrayOps
{
	class Program
	{
		static void Main(string[] args)
		{
			int[] daysOfWeek = { 1, 2, 3, 4, 5, 6, 7 };
			object[] objArr = daysOfWeek;

			foreach (var item in objArr)
			{
				Console.WriteLine(item);
			}


			Console.ReadLine();
		}
	}

}

", "C#")<img src="../../Content/Images/ArrayAsReference/CannotImplicitlyConvertTypeIntArrayToObjectArray.png" alt="" />
        </p>
        <p>Array Covariance is a problem. In the code above to above notice <code>objArr</code>. After assigning <code>daysOfWeek</code> to <code>objArr</code> we can still change <code>objArr[0]=Foo</code> and not a string. This won't throw an error at compile time but it will throw an error at runtime. The reason is that when daysOfWeek was assigned to objArr, the type of objArr was created. Now when some other type was tried to insert into objArr it threw a <code>System.ArrayTypeMismatchException</code> This only says to us "don't use Array Covariance"</p>
        <p>Covariance is supported by Array and <code>@Html.Raw(Html.Encode("IEnumerable<T>"))</code> and <code>@Html.Raw(Html.Encode("IEnumerator<T>"))</code>. The later throws a compile time error unlike arrays, so it is useful and good.</p>
        <p>
            Covariance except the ones described above are not supported by any other Collection. i.e. <code>@Html.Raw(Html.Encode("List<Derived>"))</code> can not be assigned to <code>@Html.Raw(Html.Encode("List<Base>"))</code>
            @Html.DisplayCode(@"

using System;
using System.Collections.Generic;

namespace BasicArrayOps
{
	class Program
	{
		static void Main(string[] args)
		{
			List<string> lstString = new List<String>(){
									 ""Monday"",
									 ""Tuesday""
									 };
			List<object> lstObject = lstString;

			Console.ReadLine();
		}
	}

}

", "c#")
        </p>
        <p><img src="../../Content/Images/ArrayAsReference/CovarianceNotAllowedforlists.png" alt="" /></p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">What Arrays can do</div>
    </div>
    <div class="panel-body">
        <ul>
            <li><a href="https://msdn.microsoft.com/en-us/library/system.array%28v=vs.110%29.aspx">Go to the msdn page for arrays</a> to find the full set of functionalities</li>
            <li>
                Array Features
                <ul>
                    <li>Copying the array- <code>x.CopyTo(y,0)</code> where <code>x</code> &amp; <code>y</code> are arrays of same types or <code>Array.Copy</code></li>
                    <li>Rearranging elements -<code>Array.Reverse</code>, <code>Array.Sort</code> for reversing inplace. use <code>x.Reverse()</code> of <code>System.Linq</code> to return a reversed array and leaving the old array as it is.</li>
                    <li>Finding elements - <code>Array.IndexOf</code>or <code>Array.BinarySearch</code></li>
                    <li>
                        Sorting
                        <p>
                            Lets talk about <code>IComparer</code>. An <code>@Html.Raw(Html.Encode("IComparer<T>"))</code> says that i know how to compare 2 objects of type <code>T</code>.
                        </p>
                        <p>
                            Take the example of comparing <code>int</code>
                            @Html.DisplayCode(@"
using System;

namespace BasicArrayOps
{
	class Program
	{
		static void Main(string[] args)
		{
			int x = 5;
			int y = 10;
			Console.WriteLine(y.CompareTo(x)); //outputs 1
			Console.WriteLine(x.CompareTo(y)); //outputs -1


			Console.ReadLine();
		}
	}

}


", "c#") <img src="../../Content/Images/ArrayAsReference/intCompareTo.png" alt="" />
                        </p>
                        <p>
                            Another example of <code>string</code>
                            @Html.DisplayCode(@"
using System;

namespace BasicArrayOps
{
	class Program
	{
		static void Main(string[] args)
		{
			string x = ""Monday"";
			string y = ""Wednesday"";
			Console.WriteLine(x.CompareTo(y)); //outputs -1

			Console.ReadLine();
		}
	}

}

", "c#") As per the definition in msdn it says "Compares this instance with a specified Object and indicates whether this instance precedes, follows, or appears in the same position in the sort order as the specified string. It compares alphabetically. a comes before b so a.CompareTo(b) will give -1. It actually compares based on a lot of factors as mentioned <a href="https://msdn.microsoft.com/en-us/library/35f0x18w(v=vs.110).aspx">here</a>. See the "Remarks" section.
                        </p>
                        <p>
                            But what about Complex types. How do we compare them?
                            Usually we don't make a direct comparison of two complex types. But consider the case of Sorting a collection of the type. In this case we would need a way to compare them.
                            <code>Array.Sort</code> accepts the array to be sorted and an <code>IComparer</code>. This IComparer will be of your type. Basically an IComparer says that i know how to compare 2 objects of a type.
                            @Html.DisplayCode(@"
using System;
using System.Collections.Generic;

namespace BasicArrayOps
{
	class Program
	{
		static void Main(string[] args)
		{
			Employee e1 = new Employee { Name = ""Suyash"", EmpId = 2 };
			Employee e2 = new Employee { Name = ""Scott"", EmpId = 1 };

			Employee[] employees = new Employee[] { e1, e2 };
			Array.Sort(employees, new EmployeeComparer());

			foreach (var employee in employees)
			{
				Console.WriteLine(employee.Name);
			}

			Console.WriteLine();


			foreach (var employee in employees)
			{
				Console.WriteLine(employee.Name);
			}


			Console.ReadLine();
		}

	}


	public class Employee
	{
		public string Name { get; set; }
		public int EmpId { get; set; }
	}

	public class EmployeeComparer : IComparer<Employee>
	{
		public int Compare(Employee x, Employee y)
		{
			if (x.EmpId < y.EmpId)
			{
				return -1;
			}
			else if (x.EmpId>y.EmpId)
			{
				return 1;
			}
			return 0;
		}
	}

}


", "c#")
                        </p>
                        <p><img src="../../Content/Images/ArrayAsReference/ComplexTypeSortingbyIComparer.png" alt="" /></p>
                        <p>Notice that "Suyash" and "Scott" were not sorted in the first output, but sorted based on the employee id in the second output</p>
                    </li>
                </ul>
            </li>
            <li>LINQ extension methods - <code>using System.Linq</code></li>
        </ul>
        <p><img src="../../Content/Images/ArrayAsReference/arraymemebervslinq.png" alt="" /></p>
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Collection Interfaces</div>
    </div>
    <div class="panel-body">
        Module Overview
        <ul>
            <li>
                Interface hierarchy
                <p><img src="../../Content/Images/Interfaces/1.png" alt="" /></p>
                <ul>
                    <li>Core generic interfaces</li>
                    <li>Read-only interfaces</li>
                    <li>Older non-generic interfaces</li>
                </ul>
            </li>
            <li>
                Specific interfaces
                <ul>
                    <li><code>@Html.Raw(Html.Encode("IEnumerable<T>"))</code></li>
                    <li><code>@Html.Raw(Html.Encode("ICollection<T>"))</code></li>
                    <li><code>@Html.Raw(Html.Encode("IList<T>"))</code></li>
                    <li><code>@Html.Raw(Html.Encode("IDictionary<TKey, TValue>"))</code></li>
                    <li><code>@Html.Raw(Html.Encode("ISet<T>"))</code></li>
                </ul>
            </li>
            <li>Explicit Implementation</li>
        </ul>
    </div>
</div>
<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Core Generic Interfaces</div>
    </div>
    <div class="panel-body">
        <ul>
            <li>
                <code>@Html.Raw(Html.Encode("IEnumerable<T>"))</code>. It says "You can iterate my elements". Linq hooks in here because most of the Linq extension methods are on <code>@Html.Raw(Html.Encode("IEnumerable<T>"))</code> and its derived types.
            </li>
            <li>
                <code>@Html.Raw(Html.Encode("ICollection<T>"))</code>. It says "I know how many elements i have". A Type which implements this interface is really a collection. This is what represents an in memory data structure that has one or more elements.
                <p>This differs from an <code>@Html.Raw(Html.Encode("IEnumerable<T>"))</code>. A collection may have an enumerator through which we can iterate over the elements of a collection. It is possible to have a collection which may deny iteration over all the elements. It may only allow other Collection operations like "Looking up for an element" or other Writing operations.</p>
                <p><code>@Html.Raw(Html.Encode("ICollection<T>"))</code> has a property <code>Count</code> because it is supposed to know and do all the operations on a collection. However, Enumeration is just one of the operation that a collection can have. <code>@Html.Raw(Html.Encode("IEnumerable<T>"))</code> does not have a Count property.</p>

            </li>
            <li><code>@Html.Raw(Html.Encode("ICollection<T>"))</code> doesn't say anything about the type of collection. Is it an <code>@Html.Raw(Html.Encode("IList<T>"))</code>, an <code>@Html.Raw(Html.Encode("IDictionary<TKey, TValue>"))</code> or an <code>@Html.Raw(Html.Encode("ISet<T>"))</code></li>
        </ul>
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">ReadOnly Interfaces</div>
    </div>
    <div class="panel-body">
        These are new in .NET4.5
        <ul>
            <li>
                <code>@Html.Raw(Html.Encode("IReadOnlyCollection<T>"))</code>
                It too derives from <code>@Html.Raw(Html.Encode("IEnumerable<T>"))</code> but remember it is only for enumeration and nothing else like modification of collection.
            </li>
            <li><code>@Html.Raw(Html.Encode("IReadOnlyList<T>"))</code></li>
            <li><code>@Html.Raw(Html.Encode("IReadOnlyDictionary<T>"))</code></li>
            <li>No Read Only collection for Set</li>
        </ul>
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Old Non-Generic Interfaces</div>
    </div>
    <div class="panel-body">
        <ul>
            <li>
                <code>IEnumerable</code> Only thing worth noticing is that <code>@Html.Raw(Html.Encode("IEnumerable<T>"))</code> is derived from <code>IEnumerable</code>. The reason for this was that you should always be able to cast a generic interface to the old non generic interface as such:
                @Html.DisplayCode(@"
IEnumerable<string> genericEnum = // initialize
IEnumerable old = genericEnum
", "")
                <p>Why would we want to do that? Well the answer is backward compatibility.</p>
            </li>
            <li><code>ICollection</code></li>
            <li><code>IList</code></li>
            <li><code>IDictionary</code></li>
        </ul>
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title"><code>@Html.Raw(Html.Encode("IEnumerable<T>"))</code></div>
    </div>
    <div class="panel-body">
        <p>
            This just has one member.
            @Html.DisplayCode(@"
IEnumerator<T> GetEnumerator()
", "c#")
        </p>
        <p>Only purpose of a type which implements an <code>@Html.Raw(Html.Encode("IEnumerable<T>"))</code> is to provide an <em><strong>enumerator</strong></em>. This enumerator is reponsible to enumerate over the elements</p>
        <p><code>foreach</code> can enumerate over an <code>@Html.Raw(Html.Encode("IEnumerable<T>"))</code></p>
        <p>Note: <code>foreach</code> is <em><strong>not restricted</strong></em> to enumerate just the types which are <code>@Html.Raw(Html.Encode("IEnumerable<T>"))</code></p>
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title"><code>@Html.Raw(Html.Encode("ICollection<T>"))</code></div>
    </div>
    <div class="panel-body">
        <p><img src="../../Content/Images/Interfaces/2.png" alt="" /></p>
        <p><code>@Html.Raw(Html.Encode("ICollection<T>"))</code> has a property <code>Count</code> and <code>@Html.Raw(Html.Encode("IEnumerable<T>"))</code> has an extension method <code>Count()</code> provided by <code>System.Linq</code>. This method internally refers to <code>Count</code> property if available.</p>
        <p>
            <code>@Html.Raw(Html.Encode("ICollection<T>.IsReadOnly"))</code> lets you know if it is "OK" to add/remove/modify an element
            @Html.DisplayCode(@"
using System;
using System.Collections.Generic;

namespace BasicArrayOps
{
    class Program
    {
        static void Main(string[] args)
        {
            string[] daysOfWeek = {
                                      ""Monday"",
                                      ""Tuesday"",
                                      ""Wednesday"",
                                      ""Thursday"",
                                      ""Friday"",
                                      ""Saturday"",
                                      ""Sunday""
                                  };
            ICollection<string> daysOfWeekCollection = daysOfWeek;

            if (!daysOfWeekCollection.IsReadOnly)
            {
                daysOfWeekCollection.Add(""SlaveDay"");
            }
            else
            {
                Console.WriteLine(""daysOfWeekCollection is a readonly"");
            }

            foreach (string dayOfWeek in daysOfWeekCollection)
            {
                Console.WriteLine(dayOfWeek);
            }

            Console.ReadLine();
        }

    }

}


", "c#")<img src="../../Content/Images/Interfaces/3.png" alt="" />

        </p>
        <p>
            <code>Add</code> on an <code>@Html.Raw(Html.Encode("ICollection<T>"))</code> is available but may fail if the collection actually is a readOnly. However <code>@Html.Raw(Html.Encode("ICollection<T>.IsReadOnly"))</code> does not restricts the modification of the collection element.
            @Html.DisplayCode(@"
using System;
using System.Collections.Generic;

namespace BasicArrayOps
{
    class Program
    {
        static void Main(string[] args)
        {
            string[] daysOfWeek = {
                                      ""Monday"",
                                      ""Tuesday"",
                                      ""Wednesday"",
                                      ""Thursday"",
                                      ""Friday"",
                                      ""Saturday"",
                                      ""Sunday""
                                  };
            ICollection<string> daysOfWeekCollection = daysOfWeek;

            (daysOfWeekCollection as string[])[5] = ""Slaveday"";

            foreach (string dayOfWeek in daysOfWeekCollection)
            {
                Console.WriteLine(dayOfWeek);
            }

            Console.ReadLine();
        }

    }

}

", "c#")<img src="../../Content/Images/Interfaces/4.png" alt="" />
        </p>
        <p>Be careful about IsReadOnly property</p>
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Explicit Interface Implementation</div>
    </div>
    <div class="panel-body">
        Collection such as an array needs to be explicitly casted to an Interface to have some methods available.
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title"><code>@Html.Raw(Html.Encode("IReadOnlyCollection<T>"))</code></div>
    </div>
    <div class="panel-body">
        <img src="../../Content/Images/Interfaces/5.png" alt="" />
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title"><code>@Html.Raw(Html.Encode("IList<T>"))</code></div>
    </div>
    <div class="panel-body">
        <p>It says "You can look up my elements with an index". So <code>@Html.Raw(Html.Encode("IList<T>"))</code> is a collection that allows element lookup via index. Also the enumerator is available.</p>
        <p><em><strong>Arrays implement </strong></em><code>@Html.Raw(Html.Encode("IList<T>"))</code></p>
        <p><img src="../../Content/Images/Interfaces/6.png" alt="" /></p>
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title"><code>@Html.Raw(Html.Encode("IReadOnlyList<T>"))</code></div>
    </div>
    <div class="panel-body">
        <p><img src="../../Content/Images/Interfaces/7.png" alt="" /></p>
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title"><code>@Html.Raw(Html.Encode("IDictionary<TKey, TValue>"))</code></div>
    </div>
    <div class="panel-body">
        <p>It says "You can look up my elements with a key"</p>
        <p><img src="../../Content/Images/Interfaces/8.png" alt="" /></p>
        <p>An <code>@Html.Raw(Html.Encode("IDictionary<TKey, TValue>"))</code> is essentially a collection of <code>@Html.Raw(Html.Encode("KeyValuePair<TKey, TValue>"))</code></p>
        <p><img src="../../Content/Images/Interfaces/9.png" alt="" /></p>
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title"><code>@Html.Raw(Html.Encode("IReadOnlyDictionary<TKey, TValue>"))</code></div>
    </div>
    <div class="panel-body">
        <p><img src="../../Content/Images/Interfaces/10.png" alt="" /></p>
        <p>indexer is obviously only readonly</p>
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title"><code>@Html.Raw(Html.Encode("ISet<T>"))</code></div>
    </div>
    <div class="panel-body">
        <img src="../../Content/Images/Interfaces/11.png" alt="" />
    </div>
</div>
<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Lists</div>
    </div>
    <div class="panel-body">
        Overview
        <ul>
            <li>
                <code>@Html.Raw(Html.Encode("List<T>"))</code>
                <ul>
                    <li>Extensive API</li>
                    <li>Like array but with adding/removing elements</li>
                </ul>
            </li>
            <li>
                <code>@Html.Raw(Html.Encode("ReadOnlyCollection<T>"))</code>
                <ul>
                    <li>Read-only wrapper for lists</li>
                </ul>
            </li>
            <li>
                <code>@Html.Raw(Html.Encode("Collection<T>"))</code>
                <ul>
                    <li>Allows lists to be customized</li>
                </ul>
            </li>
            <li>
                <code>@Html.Raw(Html.Encode("ObservableCollection<T>"))</code>
                <ul>
                    <li>List with change notifications</li>
                </ul>
            </li>
        </ul>
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title"><code>@Html.Raw(Html.Encode("List<T>"))</code></div>
    </div>
    <div class="panel-body">
        <p>It is intended to give you all that an Array offers i.e. High performance, Index based. But with the bonus of Adding and Removing elements</p>
        <p>
            I mentioned earlier that internally <code>@Html.Raw(Html.Encode("List<T>"))</code> uses an <code>@Html.Raw(Html.Encode("T[]"))</code>. What happens is that by default <code>@Html.Raw(Html.Encode("List<T>"))</code> references to a <code>@Html.Raw(Html.Encode("T[]"))</code> of size 8. This can be displayed by the <code>@Html.Raw(Html.Encode("List<T>.Capacity"))</code> Property. When we start entering values in this <code>@Html.Raw(Html.Encode("List<T>"))</code>, the <code>@Html.Raw(Html.Encode("List<T>.Count"))</code> property increases it's value. When <code>@Html.Raw(Html.Encode("List<T>.Count"))</code> wants to be greater than <code>@Html.Raw(Html.Encode("List<T>.Capacity"))</code> then the old reference to <code>@Html.Raw(Html.Encode("T[]"))</code> is discarded, starts pointing to another array <code>@Html.Raw(Html.Encode("T2[]"))</code> and the values from <code>@Html.Raw(Html.Encode("T[]"))</code> is copied over to <code>@Html.Raw(Html.Encode("T2[]"))</code>. Now, <code>@Html.Raw(Html.Encode("List<T>.Count"))</code> increases by 1 and <code>@Html.Raw(Html.Encode("List<T>.Capacity"))</code> becomes 16. Let's see this in code.
            @Html.DisplayCode(@"
using System;
using System.Collections.Generic;

namespace BasicArrayOps
{
    class Program
    {
        static void Main(string[] args)
        {
            var squares = new List<int> { 1, 4, 9, 16, 25, 36, 49 };
            Console.WriteLine(""squares.Count: ""+squares.Count.ToString());
            Console.WriteLine(""squares.Capacity: ""+squares.Capacity.ToString());
            Console.ReadLine();
        }

    }
}


", "c#")<img src="../../Content/Images/List/1.png" alt="" />

        </p>
        <p>
            Lets Add 2 more values to the <code>@Html.Raw(Html.Encode("List<int>"))</code> and see the <code>@Html.Raw(Html.Encode("List<int>.Count"))</code> &amp; <code>@Html.Raw(Html.Encode("List<int>.Capacity"))</code> values change.
            @Html.DisplayCode(@"
using System;
using System.Collections.Generic;

namespace BasicArrayOps
{
    class Program
    {
        static void Main(string[] args)
        {
            var squares = new List<int> { 1, 4, 9, 16, 25, 36, 49 };
            Console.WriteLine(""squares.Count: ""+squares.Count.ToString());
            Console.WriteLine(""squares.Capacity: ""+squares.Capacity.ToString());
            Console.WriteLine();
            squares.Add(64);
            squares.Add(81);
            Console.WriteLine(""squares.Count: "" + squares.Count.ToString());
            Console.WriteLine(""squares.Capacity: "" + squares.Capacity.ToString());
            Console.ReadLine();
        }

    }




}


", "c#")<img src="../../Content/Images/List/2.png" alt="" />
        </p>
        <p>
            This may lead an idea of retrieving a value at an index that is not filled, but for which the capacity exists. This will throw an <code>ArgumentOutOfRange</code> exception.
        </p>
        <p>
            When we remove an element from the <code>@Html.Raw(Html.Encode("List<T>"))</code> the values after that value iterate till the end and gets copied over to previous index. If the value to be removed is at around the end, the operation will be faster. But if the value to be removed is at beginning, it will take a lot of time.
        </p>
        <p>
            To avoid increasing <code>@Html.Raw(Html.Encode("List<T>.Capacity"))</code> when we keep adding elements to the list, in case we already know an approximate number of elements that the list is about to have, we can initialize our list with an initial value of <code>Capacity</code>.
            @Html.DisplayCode(@"
using System;
using System.Collections.Generic;

namespace BasicArrayOps
{
    class Program
    {
        static void Main(string[] args)
        {
            var squares = new List<int>(12) { 1, 4, 9, 16, 25, 36, 49 };
            Console.WriteLine(""squares.Count: ""+squares.Count.ToString());
            Console.WriteLine(""squares.Capacity: ""+squares.Capacity.ToString());
            Console.ReadLine();
        }

    }




}


", "c#")<img src="../../Content/Images/List/3.png" alt="" />
        </p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title"><code>AsReadOnly()</code> and <code><code>@Html.Raw(Html.Encode("ReadOnlyCollection<T>"))</code></code></div>
    </div>
    <div class="panel-body">
        <p>
            <code>AsReadOnly()</code> can return a <code>@Html.Raw(Html.Encode("List<T>"))</code> which will be readOnly. Let's see this in code.
            @Html.DisplayCode(@"
using System;
using System.Collections.Generic;

namespace BasicArrayOps
{
    class Program
    {
        static void Main(string[] args)
        {
            var squares = new List<int>(12) { 1, 4, 9, 16, 25, 36, 49 };

            var copy = squares.ToArray();//This provides a copy of my list but consider a list of million elements that will take a lot of time to get copied over

            //Instead use AsReadOnly() which without copying will just make the list Read Only for copy2

            var copy2 = squares.AsReadOnly();//Notice this returns a ReadOnlyCollection<int>
            var copy3 = new ReadOnlyCollection<int>(squares);//Another way to initialize a ReadOnlyCollection<int>

            //Trying to change a value
            copy2[0] = 0; // Throws a Compile time error.

            Console.ReadLine();
        }
    }
}


", "c#")
        </p>
        <p>
            <code>@Html.Raw(Html.Encode("ReadOnlyCollection<T>"))</code> is actually a Read Only <code>@Html.Raw(Html.Encode("List<T>"))</code> so the name ReadOnly<strong>Collection</strong> is a bit misleading.
        </p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title"><code>@Html.Raw(Html.Encode("Collection<T>"))</code></div>
    </div>
    <div class="panel-body">
        <p><img src="../../Content/Images/Collection/1.png" alt="" /></p>
        <p>
            <code>@Html.Raw(Html.Encode("List<T>"))</code> methods can not be overriden. But <code>@Html.Raw(Html.Encode("Collection<T>"))</code> makes it possible to override some operations like what else should happen when an element is added/removed etc. Let's take an example of a Collection that only allows Non-Blank strings. Let's see this in code
        </p>
        <p><img src="../../Content/Images/Collection/2.png" alt="" /></p>
        <p>
            <code>InsertItem</code> &amp; <code>SetItem</code> are virtual methods.
        </p>
        <p>
            <img src="../../Content/Images/Collection/3.png" alt="" />
        </p>
        <p>
            The Interface methods <code>Add(T item)</code>, <code>Insert()</code> etc. that come as a contract from the interfaces like <code>@Html.Raw(Html.Encode("IList<T>"))</code> internally call <code>InsertItem(int index, T item)</code> which is provided as an extensibility point by <code>@Html.Raw(Html.Encode("Collection<T>"))</code>. So i can create another class that inherits from <code>@Html.Raw(Html.Encode("Collection<T>"))</code> and override these extensibility points. Lets see this in code.
            @Html.DisplayCode(@"
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace BasicArrayOps
{
    class Program
    {
        static void Main(string[] args)
        {
            NonBlankStringList lst = new NonBlankStringList();
            lst.Add(""Item added at index 0"");
            lst.Add(String.Empty);//Throws exception
            lst[0] = "" "";//Throws exception

            Console.ReadLine();
        }
    }

    public class NonBlankStringList : Collection<string>
    {
        protected override void InsertItem(int index, string item)
        {
            if (String.IsNullOrWhiteSpace(item))
            {
                throw new ArgumentException(""Elements of NonBlankStringList must not be null or whitespace"");
            }
            base.InsertItem(index, item);
        }

        protected override void SetItem(int index, string item)
        {
            if (String.IsNullOrWhiteSpace(item))
            {
                throw new ArgumentException(""Elements of NonBlankStringList must not be null or whitespace"");
            }
            base.SetItem(index, item);
        }
    }
}


", "c#")
        </p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title"><code>@Html.Raw(Html.Encode("ObservableCollection<T>"))</code></div>
    </div>
    <div class="panel-body">
        <p>It is designed to be a List that provides change notifications if anything in the list changes.</p>
        <p>
            @Html.DisplayCode(@"
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace BasicArrayOps
{
    class Program
    {
        static void Main(string[] args)
        {
            ObservableCollection<string> presidents = new ObservableCollection<string>{
                ""Jimmy Carter"",
                ""Ronald Reagan"",
                ""G W Bush""
            };

            foreach (var president in presidents)
            {
                Console.WriteLine(president);
            }

            presidents.CollectionChanged += presidents_CollectionChanged;

            presidents[0] = ""Bill Clinton"";

            Console.ReadLine();
        }

        static void presidents_CollectionChanged(object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
        {
            Console.WriteLine();
            Console.WriteLine(""President Changed"");
            Console.WriteLine();
        }
    }


}


", "c#")
        </p>
        <p><img src="../../Content/Images/Collection/4.png" alt="" /></p>
        <p><code>@Html.Raw(Html.Encode("ObservableCollection<T>"))</code> actually uses the extensibility points offered by <code>@Html.Raw(Html.Encode("Collection<T>"))</code></p>
    </div>
</div>



<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Linked Lists, Stacks and Queues</div>
    </div>
    <div class="panel-body">
        <p>They are lists but they don't provide index based element lookup because they are designed for specific data structures which are Linked Lists, Stacks and Queues</p>
        <p><img src="../../Content/Images/LinkedListStackQueue/1.png" alt="" /></p>
        <p><code>@Html.Raw(Html.Encode("LinkedList<T>"))</code> are used for the scenarios where a lot of Adding or Removing of elements happen</p>
        <p><code>@Html.Raw(Html.Encode("LinkedList<T>"))</code> allows to insert an element in between. But so does <code>@Html.Raw(Html.Encode("List<T>.Insert"))</code> method. The reason we would favor <code>@Html.Raw(Html.Encode("LinkedList<T>"))</code> is that it takes very few operations (4) to insert an element in between</p>
        <p><img src="../../Content/Images/LinkedListStackQueue/2.png" alt="" /></p>

        <p>
            <div><code>@Html.Raw(Html.Encode("LinkedList<T>"))</code> &amp; <code>@Html.Raw(Html.Encode("LinkedListNode<T>"))</code></div>
        </p>
        <p><code>@Html.Raw(Html.Encode("LinkedListNode<T>"))</code> is required for adding items to a linked list</p>
        <p>Collection Initializer is not available for <code>@Html.Raw(Html.Encode("LinkedList<T>"))</code></p>
        <p><img src="../../Content/Images/LinkedListStackQueue/3.png" alt="" /></p>
        <p><code>@Html.Raw(Html.Encode("Stack<T>"))</code> is a wrapper around <code>T[]</code></p>
        <p><code>@Html.Raw(Html.Encode("Queue<T>"))</code> is a little more complex wrapper around <code>T[]</code></p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Dictionaries</div>
    </div>
    <div class="panel-body">
        <ul>
            <li>
                <code>@Html.Raw(Html.Encode("Dictionary<TKey, TValue>"))</code>
                <ul>
                    <li>General purpose dictionary</li>
                </ul>
            </li>
            <li><code>@Html.Raw(Html.Encode("ReadOnlyDictionary<TKey, TValue>"))</code></li>
            <li>
                <code>@Html.Raw(Html.Encode("SortedList<TKey, TValue>"))</code> &amp; <code>@Html.Raw(Html.Encode("SortedDictionary<TKey, TValue>"))</code>
                <ul>
                    <li>Dictionaries that sort their elements</li>
                </ul>
            </li>
            <li>
                <code>@Html.Raw(Html.Encode("KeyedCollection<TKey, TValue>"))</code>
                <ul>
                    <li>Customizable</li>
                </ul>
            </li>
            <li>
                Hash tables
                <ul>
                    <li>Hash codes</li>
                </ul>
            </li>
        </ul>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title"><code>@Html.Raw(Html.Encode("Dictionary<TKey, TValue>"))</code></div>
    </div>
    <div class="panel-body">
        <p>Just a basic implementation of <code>@Html.Raw(Html.Encode("IDictionary<TKey, TValue>"))</code></p>
        <p>
            General Working, Let's see the code
            @Html.DisplayCode(@"
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace BasicArrayOps
{
    class Program
    {
        static void Main(string[] args)
        {
            var harryPotterMovies = new Dictionary<String, HarryPotterMovie>()
            {
                {""PS"",  new HarryPotterMovie{Name=""Harry Potter and the Philosopher's Stone"", ReleaseYear=2001}},
                {""CS"",  new HarryPotterMovie{Name = ""Harry Potter and the Chamber of Secrets"", ReleaseYear=2002}},
                {""PA"",  new HarryPotterMovie{Name = ""Harry Potter and the Prisoner of Azkaban"", ReleaseYear=2004}},
                {""GF"",  new HarryPotterMovie{Name=""Harry Potter and the Goblet of Fire"", ReleaseYear=2005}},
                {""DH1"", new HarryPotterMovie{Name=""Harry Potter and the Deathly Hallows: Part 1"", ReleaseYear=2010}}
            };

            foreach (var item in harryPotterMovies)
            {
                Console.WriteLine(item);
            }

            Console.ReadLine();
        }
    }

    public class HarryPotterMovie
    {
        public String Name { get; set; }
        public Int32 ReleaseYear { get; set; }

        public HarryPotterMovie()
        {

        }

        public HarryPotterMovie(String _name, Int32 _releaseYear)
        {
            Name = _name;
            ReleaseYear = _releaseYear;
        }

        public override string ToString()
        {
            return String.Format(""{0}, Release: {1}"", Name, ReleaseYear);
        }
    }
}


", "c#")<img src="../../Content/Images/Dictionary/1.png" alt="" />
        </p>
        <p>
            Notice the output is specially formatted with square brackets. This is because the element in the <code>foreach</code> loop is a <code>@Html.Raw(Html.Encode("KeyValuePair<TKey, TValue>"))</code> whose <code>ToString()</code> method is overridden to display key and value within square brackets.
        </p>
        <p>
            In case we want to access somthing that is not available in the Dictionary, a <code>KeyNotFoundException</code> exception is thrown. To avoid this exception we use the <code>TryGetValue</code> method. Let's see this in code.
            @Html.DisplayCode(@"
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace BasicArrayOps
{
    class Program
    {
        static void Main(string[] args)
        {
            var harryPotterMovies = new Dictionary<String, HarryPotterMovie>()
            {
                {""PS"",  new HarryPotterMovie{Name=""Harry Potter and the Philosopher's Stone"", ReleaseYear=2001}},
                {""CS"",  new HarryPotterMovie{Name = ""Harry Potter and the Chamber of Secrets"", ReleaseYear=2002}},
                {""PA"",  new HarryPotterMovie{Name = ""Harry Potter and the Prisoner of Azkaban"", ReleaseYear=2004}},
                {""GF"",  new HarryPotterMovie{Name=""Harry Potter and the Goblet of Fire"", ReleaseYear=2005}},
                {""DH1"", new HarryPotterMovie{Name=""Harry Potter and the Deathly Hallows: Part 1"", ReleaseYear=2010}}
            };

            foreach (var item in harryPotterMovies)
            {
                Console.WriteLine(item);
            }

            Console.WriteLine();

            Console.WriteLine(harryPotterMovies[""DH2""]);// KeyNotFound Exception

            HarryPotterMovie movie;
            var found = harryPotterMovies.TryGetValue(""DH2"", out movie);
            if (found)
            {
                Console.WriteLine(""{0}, Release: {1}"", movie.Name, movie.ReleaseYear);
            }
            else
            {
                Console.WriteLine(""Movie not found"");
            }


            Console.ReadLine();
        }
    }

    public class HarryPotterMovie
    {
        public String Name { get; set; }
        public Int32 ReleaseYear { get; set; }

        public HarryPotterMovie()
        {

        }

        public HarryPotterMovie(String _name, Int32 _releaseYear)
        {
            Name = _name;
            ReleaseYear = _releaseYear;
        }

        public override string ToString()
        {
            return String.Format(""{0}, Release: {1}"", Name, ReleaseYear);
        }
    }
}


", "c#")<img src="../../Content/Images/Dictionary/2.png" alt="" />
        </p>
        <p>
            Adding/Modifying/Removing the <code>@Html.Raw(Html.Encode("Dictionary<TKey, TValue>"))</code>
            Let's see this in code.
            @Html.DisplayCode(@"
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace BasicArrayOps
{
    class Program
    {
        static void Main(string[] args)
        {
            var harryPotterMovies = new Dictionary<String, HarryPotterMovie>()
            {
                {""PS"",  new HarryPotterMovie{Name=""Harry Potter and the Philosopher's Stone"", ReleaseYear=2001}},
                {""CS"",  new HarryPotterMovie{Name = ""Harry Potter and the Chamber of Secrets"", ReleaseYear=2002}},
                {""PA"",  new HarryPotterMovie{Name = ""Harry Potter and the Prisoner of Azkaban"", ReleaseYear=2004}},
                {""GF"",  new HarryPotterMovie{Name=""Harry Potter and the Goblet of Fire"", ReleaseYear=2005}},
                {""DH1"", new HarryPotterMovie{Name=""Harry Potter and the Deathly Hallows: Part1"", ReleaseYear=2010}}
            };



            harryPotterMovies.Add(""DH2"", new HarryPotterMovie { Name = ""Harry Potter and the Deathly Hallows: Part2"", ReleaseYear = 2011 });// This will add the value.

            harryPotterMovies[""DH2""] = new HarryPotterMovie { Name = ""Harry Potter and the Deathly Hallows: Part2"", ReleaseYear = 2011 };// Indexer can add a value

            harryPotterMovies[""DH1""] = new HarryPotterMovie { Name = ""Harry Potter and the Deathly Hallows: The First Part"", ReleaseYear = 2011 };// Indexer can also change the value

            harryPotterMovies.Add(""DH1"", new HarryPotterMovie { Name = ""Foo"", ReleaseYear = 2015 }); //This throws an ArgumentException because a dictionary must have unique Keys

            harryPotterMovies.Remove(""DH1"");//This will remove the Dictionary element with the Key ""DH1""

            foreach (var item in harryPotterMovies)
            {
                Console.WriteLine(item);
            }

            Console.ReadLine();
        }
    }

    public class HarryPotterMovie
    {
        public String Name { get; set; }
        public Int32 ReleaseYear { get; set; }

        public HarryPotterMovie()
        {

        }

        public HarryPotterMovie(String _name, Int32 _releaseYear)
        {
            Name = _name;
            ReleaseYear = _releaseYear;
        }

        public override string ToString()
        {
            return String.Format(""{0}, Release: {1}"", Name, ReleaseYear);
        }
    }
}


", "c#")
        </p>
        <p>Note that a dictionary must have unique keys.</p>
        <p><code>@Html.Raw(Html.Encode("Dictionary<TKey, TValue>.Keys"))</code> &amp; <code>@Html.Raw(Html.Encode("Dictionary<TKey, TValue>.Values"))</code> are enumerable collections. They can be used when you are working with a dictionary provided by a third party</p>
        <p><strong>Keys of <code>@Html.Raw(Html.Encode("Dictionary<Tkey, TValue>"))</code> are case sensitive</strong></p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Comparing Keys with <code>@Html.Raw(Html.Encode("IEqualityComparer<T>"))</code></div>
    </div>
    <div class="panel-body">
        <p>
            <strong>Keys of <code>@Html.Raw(Html.Encode("Dictionary<Tkey, TValue>"))</code> are case sensitive</strong>. So trying to access a dictionary element by providing a key with wrong casing will throw an exception.
        </p>
        <p>
            To fix this we need to use an overload of <code>@Html.Raw(Html.Encode("Dictionary<TKey, TValue>"))</code> which accepts an <code>@Html.Raw(Html.Encode("IEqualityComparer<T>"))</code>. Microsoft provides one such comparer by the <code>StringComparer</code> class. <code>StringComparer</code> has several static methods one of which is <code>StringComparer.InvariantCultureIgnoreCase</code> which creates a <code>@Html.Raw(Html.Encode("Dictionary<TKey, TValue>"))</code> with case insensitive keys. Let's see this in code
            @Html.DisplayCode(@"
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace BasicArrayOps
{
    class Program
    {
        static void Main(string[] args)
        {
            var harryPotterMovies = new Dictionary<String, HarryPotterMovie>(StringComparer.InvariantCultureIgnoreCase)
            {
                {""PS"",  new HarryPotterMovie{Name=""Harry Potter and the Philosopher's Stone"", ReleaseYear=2001}},
                {""CS"",  new HarryPotterMovie{Name = ""Harry Potter and the Chamber of Secrets"", ReleaseYear=2002}},
                {""PA"",  new HarryPotterMovie{Name = ""Harry Potter and the Prisoner of Azkaban"", ReleaseYear=2004}},
                {""GF"",  new HarryPotterMovie{Name=""Harry Potter and the Goblet of Fire"", ReleaseYear=2005}},
                {""DH1"", new HarryPotterMovie{Name=""Harry Potter and the Deathly Hallows: Part1"", ReleaseYear=2010}}
            };


            Console.WriteLine(harryPotterMovies[""ps""]);//No exception thrown when dictionary is constructed using StringComparer.InvariantCultureIgnoreCase


            Console.ReadLine();
        }
    }

    public class HarryPotterMovie
    {
        public String Name { get; set; }
        public Int32 ReleaseYear { get; set; }

        public HarryPotterMovie()
        {

        }

        public HarryPotterMovie(String _name, Int32 _releaseYear)
        {
            Name = _name;
            ReleaseYear = _releaseYear;
        }

        public override string ToString()
        {
            return String.Format(""{0}, Release: {1}"", Name, ReleaseYear);
        }
    }
}


", "c#")
        </p>
        <p>
            But in any case lets create our own <code>@Html.Raw(Html.Encode("IEqualityComparer<T>"))</code>. Before we we implement our own <code>@Html.Raw(Html.Encode("IEqualityComparer<T>"))</code> let's see the interface once:
        </p>
        <p><img src="../../Content/Images/Dictionary/3.png" alt="" /></p>
        <p>
            We see a method <code>GetHashCode</code>. To understand this we first need to understand how a <code>@Html.Raw(Html.Encode("Dictionary<TKey, TValue>"))</code> works internally.
            <ul>
                <li>
                    A <code>@Html.Raw(Html.Encode("Dictionary<TKey, TValue>"))</code> has a lot of buckets in which the <code>@Html.Raw(Html.Encode("KeyValuePair<TKey, TValue>"))</code> are kept.
                </li>
                <li>
                    When a new <code>@Html.Raw(Html.Encode("KeyValuePair<TKey, TValue>"))</code> is added to the dictionary, it is passed through <em><strong>Some Algorithm</strong></em> which decides the bucket for this <code>@Html.Raw(Html.Encode("KeyValuePair<TKey, TValue"))</code>.
                </li>
                <li>One bucket can contain many <code>@Html.Raw(Html.Encode("KeyValuePair<TKey, TValue>"))</code> and the <code>@Html.Raw(Html.Encode("Dictionary<TKey, TValue>"))</code> can contain many buckets</li>
                <li>These buckets internally implement <code>@Html.Raw(Html.Encode("LinkedList<T>"))</code> so overall adding/removing of a <code>@Html.Raw(Html.Encode("KeyValuePair<TKey, TValue>"))</code> is very fast</li>
                <li>On Key Lookup the key is passed to the <em><strong>Some Algorithm</strong></em> to identify the bucket. Key lookup happens in the bucket one by one and when found it is returned.</li>
                <li>This <em><strong>Some Algorithm</strong></em> actually uses the <code>Object.GetHashCode()</code> to identify the bucket. In fact every object in c# has <code>GetHashCode()</code> so that it can be used to insert and identify an object in hash-based collection such as the <code>@Html.Raw(Html.Encode("Dictionary<TKey, TValue>"))</code>, the <code>Hashtable</code> class or a type derived from the <code>DictionaryBase</code> class. HashCode is a numeric value.</li>
            </ul>
        </p>
        <p>
            Coming back to our <code>@Html.Raw(Html.Encode("IEqualityComparer<T>"))</code>. Lets see the code.
            @Html.DisplayCode(@"
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace BasicArrayOps
{
    class Program
    {
        static void Main(string[] args)
        {
            var harryPotterMovies = new Dictionary<String, HarryPotterMovie>(new UncasedStringEqualityComparer())
            {
                {""PS"",  new HarryPotterMovie{Name=""Harry Potter and the Philosopher's Stone"", ReleaseYear=2001}},
                {""CS"",  new HarryPotterMovie{Name = ""Harry Potter and the Chamber of Secrets"", ReleaseYear=2002}},
                {""PA"",  new HarryPotterMovie{Name = ""Harry Potter and the Prisoner of Azkaban"", ReleaseYear=2004}},
                {""GF"",  new HarryPotterMovie{Name=""Harry Potter and the Goblet of Fire"", ReleaseYear=2005}},
                {""DH1"", new HarryPotterMovie{Name=""Harry Potter and the Deathly Hallows: Part1"", ReleaseYear=2010}}
            };


            Console.WriteLine(harryPotterMovies[""ps""]);//No exception thrown when dictionary is constructed using StringComparer.InvariantCultureIgnoreCase


            Console.ReadLine();
        }
    }

    public class HarryPotterMovie
    {
        public String Name { get; set; }
        public Int32 ReleaseYear { get; set; }

        public HarryPotterMovie()
        {

        }

        public HarryPotterMovie(String _name, Int32 _releaseYear)
        {
            Name = _name;
            ReleaseYear = _releaseYear;
        }

        public override string ToString()
        {
            return String.Format(""{0}, Release: {1}"", Name, ReleaseYear);
        }
    }

    public class UncasedStringEqualityComparer : IEqualityComparer<String>
    {

        public bool Equals(string x, string y)
        {
            return x.ToUpper() == y.ToUpper();
        }

        public int GetHashCode(string obj)
        {
            return obj.GetHashCode();
        }
    }
}


", "c#")
        </p>
        <p>But this code throws an exception "KeyNotFound". What happened?</p>
        <p>
            Well we know that <code>"PS"</code> &amp; <code>"ps"</code> are essentially 2 different strings. So, <code>("PS").GetHashCode()</code> &amp; <code>("ps").GetHashCode()</code> will be different. When we added <code>PS</code> to our Dictionary, the <em><strong>Some Algorithm</strong></em> used <code>("PS").GetHashCode()</code> and moved the value to <em><strong>Bucket1</strong></em>. On Lookup <em><strong>Some Algorithm</strong></em> will produce a different value for <code>("ps").GetHashCode()</code> and will lookup in another <em><strong>Bucket2</strong></em>. So a <code>KeyNotFound</code> exception.
        </p>
        <p>
            So, in our custom <code>@Html.Raw(Html.Encode("IEqualityComparer<T>"))</code> we will implement <code>GetHashCode()</code> as such:
            @Html.DisplayCode(@"
return obj.ToUpper().GetHashCode();
", "c#")
        </p>
        <p>And now if we run our code, it works just fine!</p>
        <p>
            Something about HashCodes
            <ul>
                <li>If two objects are equal, they must return the same hash code</li>
            </ul>
        </p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title"><code>@Html.Raw(Html.Encode("ReadOnlyDictionary<TKey, TValue>"))</code></div>
    </div>
    <div class="panel-body">
        <p>Wrapper around <code>@Html.Raw(Html.Encode("Dictionary<TKey, TValue>"))</code> with only read only properties</p>
        <p><code>Add</code> method is not exposed</p>
        <p>To initialize it pass the <code>@Html.Raw(Html.Encode("Dictionary<TKey, TValue>"))</code> to the constructor.</p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title"><code>@Html.Raw(Html.Encode("SortedList<TKey, TValue>"))</code></div>
    </div>
    <div class="panel-body">
        <p>Similar as dictionary, but on enumeration it will output elements in a sorted order of the Key.</p>
        <p>The name contains "List", but it is actually a "Dictionary". The name contains "List" because remember List is something that has something to do with the order.</p>
        <p>Modifications are slow because on adding/removing the list needs to get sorted again.</p>
        <p>Pass other collections to initialize</p>
        <p>Constructor accepts an <code>@Html.Raw(Html.Encode("IComparer<T>"))</code>. We have already seen how to create an <code>@Html.Raw(Html.Encode("IComparer<T>"))</code></p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title"><code>@Html.Raw(Html.Encode("SortedDictionary<TKey, TValue>"))</code></div>
    </div>
    <div class="panel-body">
        <p>
            In terms of functionality <code>@Html.Raw(Html.Encode("SortedDictionary<TKey, TValue>"))</code> is exactly same as <code>@Html.Raw(Html.Encode("SortedList<TKey, TValue>"))</code>
        </p>
        <p>
            The difference is in the internal implementation. <code>@Html.Raw(Html.Encode("SortedDictionary<TKey, TValue>"))</code> uses a data structure called "Balanced Tree"
        </p>
        <p>Faster than <code>@Html.Raw(Html.Encode("SortedList<TKey, TValue>"))</code> in terms of adding/removing/modifying/lookup</p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title"><code>@Html.Raw(Html.Encode("KeyedCollection<TKey, TValue>"))</code></div>
    </div>
    <div class="panel-body">
        <p><img src="../../Content/Images/Dictionary/4.png" alt="" /></p>
        <p>
            Notice the Key is being repeated in both the Key and the Value. Change the code as per below:
        </p>
        <p><img src="../../Content/Images/Dictionary/5.png" alt="" /></p>
        <p><img src="../../Content/Images/Dictionary/6.png" alt="" /></p>
        <p>This is not the only reason why we use <code>@Html.Raw(Html.Encode("KeyedCollection<TKey, TValue"))</code>. We want to use it because our Dictionary is now customizable. See the overridable methods.</p>
        <p>It is not only a Dictionary. It is a List too!!. This means as well as looking up for element by Key, we can also look up by key. This results in a problem when the key is int. If we cast it to a List and then use the indexer for lookup using int indexes, it works.</p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Sets</div>
    </div>
    <div class="panel-body">
        Module Overview
        <ul>
            <li><code>@Html.Raw(Html.Encode("HashSet<T>"))</code></li>
            <li><code>@Html.Raw(Html.Encode("SortedSet<T>"))</code></li>
            <li>
                The <code>@Html.Raw(Html.Encode("ISet<T>"))</code>
                <ul>
                    <li>Set Operations</li>
                    <li>Set comparisons</li>
                </ul>
            </li>
            <li>Uniqueness of Elements</li>
        </ul>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title"><code>@Html.Raw(Html.Encode("HashSet<T>"))</code></div>
    </div>
    <div class="panel-body">
        <p>
            <code>@Html.Raw(Html.Encode("HashSet<T>"))</code> is a set as it implements <code>@Html.Raw(Html.Encode("ISet<T>"))</code>. But is is important for another reason. It represents a collection that has no exposed property of order or location of an element. It just represents what a collection contains and what it doesn't. Well, this can be done by a <code>@Html.Raw(Html.Encode("List<T>"))</code> too. But remember a <code>@Html.Raw(Html.Encode("List<T>"))</code> can have duplicate values; wheras a <code>@Html.Raw(Html.Encode("HashSet<T>"))</code> will not. It provides uniqueness.
        </p>
        <p>
            Its internal implementation is somewhat like a <code>@Html.Raw(Html.Encode("Dictionary<TKey, TValue"))</code>. i.e. buckets. Only difference is that the buckets have values not keys.
        </p>
        <p>
            Let's see the code
            @Html.DisplayCode(@"
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace BasicArrayOps
{
    class Program
    {
        static void Main(string[] args)
        {
            var cities = new List<string>()
            {
                ""Delhi"",
                ""Mumbai"",
                ""Chennai"",
                ""Kolkata""
            };

            cities.Add(""Kolkata"");

            foreach (var item in cities)
            {
                Console.WriteLine(item);
            }

            Console.WriteLine();

            var hashCities = new HashSet<string>()
            {
                ""Delhi"",
                ""Mumbai"",
                ""Chennai"",
                ""Kolkata""
            };

            hashCities.Add(""Kolkata"");

            foreach (var item in hashCities)
            {
                Console.WriteLine(item);
            }

            Console.ReadLine();
        }
    }


}


", "c#")
        </p>
        <p><img src="../../Content/Images/Set/1.png" alt="" /></p>
        <p>If you notice adding another "Kolkata" didn't throw an error. a <code>@Html.Raw(Html.Encode("HashSet<T>"))</code> checks the bucket if the value already exists or not. Adds if not. So there is Good performance for checking if an element is already in the set.</p>
        <p>So there is a guarantee that there can not be a value more than once in a <code>@Html.Raw(Html.Encode("HashSet<T>"))</code></p>
        <p>
            The <code>@Html.Raw(Html.Encode("HashSet<T>.Add"))</code> method returns a <code>Boolean</code> that represents if the value was added or not(based on if it already existed in the bucket or not)
        </p>
        <p>Another business issue can be that "Mumbai" &amp; "mumbai" are 2 different strings for <code>@Html.Raw(Html.Encode("HashSet<T>"))</code>. To avoid this there is an extensibility point. Provide an <code>@Html.Raw(Html.Encode("IEqualityComparer<T>"))</code> to the constructor.</p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title"><code>Intersection</code> and <code>IntersectsWith()</code></div>
    </div>
    <div class="panel-body">
        <p><code>IntersetsWith()</code> modifies the set inline and accepts any collection as the 2nd parameter</p>
        <p><code>Intersection</code> is a <code>System.Linq</code> extension method. It returns a new Enumerable. This works with any collection and not just <code>@Html.Raw(Html.Encode("HashSet<T>"))</code></p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Union, Difference and Symmetric Difference</div>
    </div>
    <div class="panel-body">
        <p><code>Union</code> &amp; <code>UnionWith</code></p>
        <p><code>SymmetricExceptWith</code>: Find values that are in ONLY ONE collection</p>
        <p><code>ExceptWith, Except</code>: Find values that are n ONLY THE FIRST collection</p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Comparing Elements and <code>SetEquals()</code></div>
    </div>
    <div class="panel-body">
        <p><img src="../../Content/Images/Set/2.png" alt="" /></p>
        <p><img src="../../Content/Images/Set/3.png" alt="" /></p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Set Comparisons and Subsets</div>
    </div>
    <div class="panel-body">
        <img src="../../Content/Images/Set/4.png" alt="" />
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title"><code>@Html.Raw(Html.Encode("SoretedSet<T>"))</code></div>
    </div>
    <div class="panel-body">
        <p><img src="../../Content/Images/Set/5.png" alt="" /></p>
        <p>Instead of using a Hashset, it uses a balanced tree</p>
        <p>Enumerating elements gives them in order</p>
        <p>To distinguish between upper case and lower case, pass a <code>@Html.Raw(Html.Encode("IComparer<T>"))</code></p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Enumerators</div>
    </div>
    <div class="panel-body">
        <p>
            Notice for every collection, <code>foreach</code> works in the same way.
        </p>
        <p>
            <ul>
                <li>
                    Iterating under the hood
                    <ul>
                        <li><code>@Html.Raw(Html.Encode("IEnumerable<T>"))</code></li>
                        <li><code>@Html.Raw(Html.Encode("IEnumerator<T>"))</code></li>
                    </ul>
                </li>
                <li>the <code>foreach</code> loop : How it works using enumerators</li>
                <li>Enumerating collections that change</li>
                <li>Writing your own enumerators</li>
                <li>Enumerator covariance</li>
            </ul>
        </p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Enumerators and <code>@Html.Raw(Html.Encode("IEnumerator<T>"))</code></div>
    </div>
    <div class="panel-body">
        <p>
            The only contract of <code>@Html.Raw(Html.Encode("IEnumerable<T>"))</code> is <code>GetEnumerator()</code>. It will be the job of this enumerator to enumerte over.
        </p>
        <p><code>MoveNext()</code> will iterate and <code>Current</code> will get the current element. <code>MoveNext()</code> returns a <code>Boolean</code>. <code>true</code> if it has moved successfully to the next item</p>
        <p>There is no specific order in which the items will be returned.</p>
        <p><img src="../../Content/Images/Enumerator/1.png" alt="" /></p>
        <p><img src="../../Content/Images/Enumerator/2.png" alt="" /></p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title"><code>foreach</code> loop</div>
    </div>
    <div class="panel-body">
        <p>
            <img src="../../Content/Images/Collection/5.png" alt="" />
        </p>
        <p>
            <img src="../../Content/Images/Collection/6.png" alt="" />
        </p>
        <p>
            But if the collection is an array, it internally uses a <code>for</code> loop.
        </p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Why Don't Collections Enumerate themselves</div>
    </div>
    <div class="panel-body">
        <p>
            Why is the enumerator a completely separate object from a collection. Each collection internally has its own collection implementation. There could have been a method called enumerate in the collection interface itself. In the implementation of that method, use a for loop to iterate over the internal implementation.
        </p>
        <p>
            The reason is : "What happens if you want multiple clients to enumerate the same collection". Example: 2 threads calling the same collection. Or a nested foreach to the same collection. You don't want <code>MoveNext()</code> of the internal <code>foreach</code> to make a change for the outer <code>foreach</code>. This is why a collection should spit a new enumerator instance.
        </p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Modifying while Enumerating</div>
    </div>
    <div class="panel-body">
        <p>
            Enumerators can only be used to read the contents of a collection. They can not be used to modify which elements are in a collection. <code>@Html.Raw(Html.Encode("IEnumerator<T>"))</code> does not exposes any method that allows you to modify a collection. But it is possible to modify the collection by some other code even when the collection is being enumerated. Actually if the collection is modified while being enumerated, it throws an exception saying that the collection can no longer be enumerated over because the collection is modified.
        </p>
        <p>
            Most collections internally store a version number that describes that a collection was changed.
        </p>
        <p>
            This works for arrays. because they are not enumerated over using <code>@Html.Raw(Html.Encode("IEnumerator<T>"))</code>.
        </p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Writing your own <code>Enumerator</code></div>
    </div>
    <div class="panel-body">
        @Html.DisplayCode(@"
using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;

namespace BasicArrayOps
{
    class Program
    {
        static void Main(string[] args)
        {
            AllDaysOfWeek daysOfWeek = new AllDaysOfWeek();
            foreach (var day in daysOfWeek)
            {
                Console.WriteLine(day);
            }


            Console.ReadLine();
        }
    }

    public class AllDaysOfWeek : IEnumerable<string>
    {

        public IEnumerator<string> GetEnumerator()
        {
            yield return ""Monday"";
            yield return ""Tuesday"";
            yield return ""Wednesday"";
            yield return ""Thursday"";
            yield return ""Friday"";
            yield return ""Saturday"";
            yield return ""Sunday"";
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }
    }
    
}


", "c#")
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Enumerable Covariance</div>
    </div>
    <div class="panel-body">
        <ul>
            <li>Array covariance is allowed implicitly.</li>
            <li>Other collections covariance is not allowed directly</li>
            <li>but it is allowed for <code>@Html.Raw(Html.Encode("IEnumerable<T>"))</code> just for reading. It is not allowed for writing.</li>
            <li>It is also allowed for readonly interfaces.</li>
        </ul>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Multidimensional Arrays and Bounds</div>
    </div>
    <div class="panel-body">
        <ul>
            <li>
                Multidimensional Arrays
                <ul>
                    <li>What they are</li>
                </ul>
            </li>
            <li>
                Rank and Bounds
                <ul>
                    <li>Different array index ranges</li>
                </ul>
            </li>
            <li>
                Jagged Arrays
                <ul>
                    <li>What they are</li>
                </ul>
            </li>
        </ul>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Multidimensional Arrays</div>
    </div>
    <div class="panel-body">
        <p>
            <ul>
                <li>More than one index</li>
                <li>Only available on array collection</li>
                <li>Syntax : <code>float[,] floatArray2d = new float[4,3]</code> or <code>float[,,] floatArray3d = new float[2,3,4]</code> and so on.</li>
                <li>The number of indices required is the dimension or the <em><strong>Rank</strong></em> of an array.</li>
            </ul>
        </p>
    </div>
</div>

<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Length and Rank</div>
    </div>
    <div class="panel-body">
        <ul>
            <li>
                <code>Array.GetLength(index)</code>
            </li>
            <li><code>Array.Rank</code></li>
        </ul>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Bounds, GetLowerBound() and GetUpperBound()</div>
    </div>
    <div class="panel-body">
        <ul>
            <li><img src="../../Content/Images/Collection/7.png" alt="" /></li>
            <li><code>Array.GetLowerBound()</code>, <code>Array.GetUpperBound()</code></li>
        </ul>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Jagged Arrays</div>
    </div>
    <div class="panel-body">
        <p>Array of Arrays</p>
        <p>
            <code>float[][] floatArrayJagged</code>
        </p>
        <p>
            <code>float[][] tempsGrid = new float[4][3]</code> Throws a compiler error. This is because i am declaring the outer array here. The outer array only knows that it is to store arrays of floats. It doesn't know anything about the length of the inner arrays because array length is not part of the type, so remove the 3. <code>float[][] tempsGrid = new float[4][]</code>
        </p>
        <p>
<img src="../../Content/Images/Collection/8.png" alt="" />
        </p>
    </div>
</div>


<div class="panel panel-info">
    <div class="panel-heading">
        <div class="panel-title">Jagged vs Multidimensional</div>
    </div>
    <div class="panel-body">
        <p>concept applies to arrays <img src="../../Content/Images/Collection/9.png" alt="" />

        </p>
        <p>concept applies to all other collections<img src="../../Content/Images/Collection/10.png" alt="" />

        </p>
    </div>
</div>